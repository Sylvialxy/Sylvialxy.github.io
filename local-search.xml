<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>大前端学习</title>
    <link href="/2024/09/21/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/09/21/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>最受欢迎的是大前端路线，即，Android、iOS、鸿蒙、H5、小程序，反正都是做页面渲染。</p><h4 id="Web前端"><a href="#Web前端" class="headerlink" title="Web前端"></a>Web前端</h4><h5 id="整体目标"><a href="#整体目标" class="headerlink" title="整体目标"></a>整体目标</h5><ol><li>了解大前端的概念以及前端的能力边界</li><li>了解掌握 Web 前端基础开发环境的使用</li><li>基本掌握前端工程搭建能力</li><li>基本掌握 React 框架开发技巧</li><li>熟悉Vue框架的开发技巧</li><li>基本掌握 Node.JS 开发技巧</li><li>成为具有全栈思维的程序员及架构师</li></ol><p>前端经典面试题：输入URL后发生了什么？</p><p><a href="https://imgse.com/i/piY58nP"><img src="https://z1.ax1x.com/2023/11/15/piY58nP.md.png" alt="piY58nP.md.png" style="zoom:50%;" /></a></p><p>浏览器渲染过程：DOM树构建</p><h5 id="HTML、CS、JavaScript"><a href="#HTML、CS、JavaScript" class="headerlink" title="HTML、CS、JavaScript"></a>HTML、CS、JavaScript</h5><h5 id="DOM基本操作"><a href="#DOM基本操作" class="headerlink" title="DOM基本操作"></a>DOM基本操作</h5><p>DOM（Document Object Model — 文档对象模型）是用来呈现以及与任意 HTML 或 XML文档交互的API。</p><p>我们可以通过js调用浏览器提供的API，进行DOM的创建、查询、删除、替换等操作，还可以监听DOM的操作（如鼠标点击、键盘输入）事件，让我们对用户的操作做出响应，如今借助于React之类的框架，我们在实际开发中已经很少需要直接操作DOM了，但是仍然有必要了解一下DOM的基本设计和常用操作。</p><ul><li><p>增查删改</p></li><li><p>DOM节点属性与方法</p></li><li><p>DOM生命周期</p></li></ul><h5 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h5><p>常用事件：<br>• 文档事件，加载，卸载等。<br>• 鼠标，键盘，移动端触控，表单输入等用户交互事件<br>• 网络处理事件<br>• 其他：媒体事件，全屏等</p><p>事件绑定的两种方法：</p><ul><li>方法1：onXXXEventName 作为DOM的属性，去掉属性相当于解绑事件</li><li>方法2：addEventListener&#x2F;removeEventLister方法。一般建议用此方法。</li></ul><h5 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h5><p>事件委托的意义：<br>1.性能提升<br>2.子节点发生变化（增加或删除），不影响代码运行</p><h5 id="BOM与浏览器API"><a href="#BOM与浏览器API" class="headerlink" title="BOM与浏览器API"></a>BOM与浏览器API</h5><p>BOM(browser object model–浏览器对象模型)，属于约定俗称，在各自浏览器中都有各自的实现，并没有统一的标准。但大多数的接口都是通用的。BOM提供了独立于内容而与浏览器窗口进行交互的对象，由于BOM主要用于管理窗口与窗口之间的通讯，因此其核心对象是window。BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性，常见的对象有：document、location、navigator、screen、history。</p><h5 id="CSS中万物皆盒"><a href="#CSS中万物皆盒" class="headerlink" title="CSS中万物皆盒"></a>CSS中万物皆盒</h5><h6 id="Flex-布局-Grid-布局"><a href="#Flex-布局-Grid-布局" class="headerlink" title="Flex 布局 Grid 布局"></a>Flex 布局 Grid 布局</h6><h6 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h6><p>•使用Flex、Grid布局<br>• 媒体查询<br>• 响应式图片<br>• rem</p><h5 id="Javascript-基础语法"><a href="#Javascript-基础语法" class="headerlink" title="Javascript 基础语法"></a>Javascript 基础语法</h5><ol><li><p>变量 有三个关键字可以声明变量：var、let 和 const。</p></li><li><p>程序控制</p></li><li><p>函数 高阶函数 匿名函数 闭包</p></li><li><p>面向对象与原型链</p></li><li><p>对象代理 Proxy</p><p>Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。<br>• 比defineProperty更强大。<br>• ES6新语法<br>• vue3双向绑定基于Proxy实现</p></li><li><p>异步编程</p><p>异步通常用于处理一些耗时的操作，比如说IO、网络请求、耗时计算等，在早期处理异步时，我们通常会使用事件和回调来处理。常见的异步有，事件监听、setTimeout、setInterval等</p></li></ol><p>Promise 就是用来解决异步回调问题而出现的解决方案。它让你能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。</p><p>一个 Promise 必然处于以下几种状态之一：<br>• 待定（pending）: 初始状态，既没有被兑现，也没有被拒绝。<br>• 已兑现（fulfilled）: 意味着操作成功完成。<br>• 已拒绝（rejected）: 意味着操作失败。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//用 Promise 和 setTimeout 来封装一个异步请求面积的方法</span><br>fuction <span class="hljs-title function_">asyncArea</span>(<span class="hljs-params">length</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-title function_">setTimeout</span>(<span class="hljs-params">()=&gt;</span>)&#123;<br>           <span class="hljs-keyword">if</span> (length&gt;<span class="hljs-number">0</span>) <span class="hljs-title function_">resolve</span>(length*length)<br>           <span class="hljs-keyword">else</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`invalid length: <span class="hljs-subst">$&#123;length&#125;</span>`</span>))<br>&#125;,<span class="hljs-number">500</span>)<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>Promise 通过 then 来进行异步请求虽然改善了回调的问题，但还是不够优雅，好在现在我们可以<br>通过 async&#x2F;await 语法，使用串行的语法进行异步调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> fuction <span class="hljs-title function_">test_1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br>    <span class="hljs-keyword">let</span> result_1=<span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncArea</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">let</span> result_2=<span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncArea</span>(result_1+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">let</span> result_3=<span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncArea</span>(result_2+<span class="hljs-number">1</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;test_1&#x27;</span>,result_3)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`cost <span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()-start&#125;</span>ms`</span>)<br>&#125;<br><span class="hljs-title function_">test_1</span>()<br><br><span class="hljs-keyword">async</span> fuction <span class="hljs-title function_">test_2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br>    <span class="hljs-keyword">let</span> result=<span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<br>        <span class="hljs-title function_">asyncArea</span>(<span class="hljs-number">1</span>),<br>        <span class="hljs-title function_">asyncArea</span>(<span class="hljs-number">2</span>),<br>        <span class="hljs-title function_">asyncArea</span>(<span class="hljs-number">3</span>),<br>        <span class="hljs-title function_">asyncArea</span>(<span class="hljs-number">4</span>),<br>        <span class="hljs-title function_">asyncArea</span>(<span class="hljs-number">5</span>)<br>    ])<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;test_2&#x27;</span>,result)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`cost <span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()-start&#125;</span>ms`</span>)<br>&#125;<br><span class="hljs-title function_">test_2</span>()<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> fuction <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncArea</span>(-<span class="hljs-number">1</span>)<br>        cnsole.<span class="hljs-title function_">log</span>(result)<br>    &#125;<span class="hljs-keyword">catch</span>(error)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">message</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-title function_">asyncArea</span>(-<span class="hljs-number">1</span>)<br>    &#125;<span class="hljs-keyword">catch</span>(error)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">message</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-title function_">asyncArea</span>(-<span class="hljs-number">1</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span>&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>,error.<span class="hljs-property">message</span>)<br>        &#125;) <br>    &#125;<span class="hljs-keyword">catch</span>(error)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>,error.<span class="hljs-property">message</span>)<br>    &#125;<br>&#125;<br><span class="hljs-title function_">run</span>()<br></code></pre></td></tr></table></figure><p>常见对象及其API</p><ol><li>String</li><li>Array</li><li>Object</li><li>Set</li><li>Map</li><li>JSON</li><li>Math</li><li>XMLHttpRequest</li><li>Storage</li><li>Error</li></ol><h5 id="前端工程化与Typescript"><a href="#前端工程化与Typescript" class="headerlink" title="前端工程化与Typescript"></a>前端工程化与Typescript</h5><p>在不使用模块系统的情况下，项目化变得难以维护。</p><ul><li>什么是前端工程化？</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">模块化、组件化、打包方案、自动化流程<br></code></pre></td></tr></table></figure><p>最终目标:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">高性能、稳定性<span class="hljs-comment">(reliability)</span>、可用性<span class="hljs-comment">(usability)</span>、可维护性<span class="hljs-comment">(maintainability)</span>、可访问性<span class="hljs-comment">(accesibility)</span><br></code></pre></td></tr></table></figure><ul><li><p>JS模块化</p><ul><li><p>CommonJs</p><p>使用module.exports导出、require导入</p></li><li><p>EsModules</p><p>可以使用export和export default,s使用import语法导入，单个导入必须使用花括号。</p></li></ul></li><li><p>Node.js与模块化</p></li></ul><p>作为一个异步事件驱动的JavaScript运行时，Node.js被设计用来构建可扩展的网络应用。在下面的“Hello World”示例中，可以并发处理许多连接，每一个连接都会触发一个回调，而当没有可做的事情时，Node.js就会进入休眠状态。</p><p>-<br>  包管理器npm安装</p><ul><li>安装node.js会自带</li><li>npm中国镜像npm config set registry&#x3D;<a href="https://registry.npmmirror.com/">https://registry.npmmirror.com</a>. </li><li>npm config ls</li><li>执行npm view react看下效果</li><li>Node.js默认是CommonJs方案（因为先有Node.js，后有es6<br>分类：</li><li>系统模块</li><li>业务模块<ul><li>社区三方模块</li><li>自定义</li></ul></li></ul><p>Node.js是和Java&#x2F;Go&#x2F;C++一样，有文件，网络，系统等能力<br>Node.js主要应用场景:服务端开发(传统服务器，ServerLess)，本地工具开发，工程化工具开发Node.js模块化主要是CommonJs，也支持ESModule,未来ESModule也会是主流<br>npm不是唯一的包管理方式，还有pnpm,yarn</p><h5 id="Webpack5学习"><a href="#Webpack5学习" class="headerlink" title="Webpack5学习"></a>Webpack5学习</h5><p>打包所有的资源</p><ol><li><strong>缓存问题（dist&#x2F;main.js 文件名固定）：</strong></li></ol><ul><li>使用文件版本号：在每次文件内容变化时，可以在文件名中添加版本号或者哈希值，例如 <code>main.&lt;hash&gt;.js</code>，这样可以确保浏览器每次获取到的文件都是新的，从而避免缓存问题。</li></ul><ol start="2"><li><strong>模块化：引入 CSS 文件：</strong></li></ol><ul><li>使用模块化打包工具：如果你使用类似 Webpack 的模块化打包工具，它们通常支持引入 CSS 文件，并能够将 CSS 文件打包到最终的输出文件中。你可以使用类似 <code>style-loader</code> 或 <code>css-loader</code> 这样的 loader 来处理 CSS 文件的导入和打包。</li></ul><ol start="3"><li><strong>模块化：引入 TypeScript 文件，如何编译：</strong></li></ol><ul><li><pre><code class="hljs">TypeScript（TS）是一种由微软开发的开源编程语言，是 JavaScript 的超集，意味着所有有效的 JavaScript 代码也是有效的 TypeScript 代码。TypeScript 引入了静态类型检查，接口，类，命名空间等概念，以提高代码的可读性和维护性。<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">  <br>- 使用 TypeScript 编译器：安装 TypeScript 并创建一个 `tsconfig.json` 文件，然后运行 `tsc` 命令，它将编译 TypeScript 文件为 JavaScript。你也可以使用类似 Webpack 的工具，配置相应的 loader 来处理 TypeScript 文件。<br>  <br>   ```json<br>   // tsconfig.json<br>   &#123;<br>     <span class="hljs-string">&quot;compilerOptions&quot;</span>: &#123;<br>       <span class="hljs-string">&quot;target&quot;</span>: <span class="hljs-string">&quot;es5&quot;</span>,<br>       <span class="hljs-string">&quot;module&quot;</span>: <span class="hljs-string">&quot;commonjs&quot;</span>,<br>       <span class="hljs-string">&quot;strict&quot;</span>: <span class="hljs-literal">true</span><br>  &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul><ol start="4"><li><strong>前后端分离时，请求跨域怎么办：</strong><ul><li><p><strong>服务器端设置跨域头：</strong> 在后端服务器的响应中添加跨域头，允许特定的域访问资源。在 Express 中，你可以使用 <code>cors</code> 中间件来处理跨域请求。</p></li><li><p>Express.js（通常简称为 Express）是一款基于 Node.js 平台的 Web 应用程序框架，它提供了一系列丰富的功能来构建 Web 和移动应用。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">   <span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cors&#x27;</span>);<br>   <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br>   app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cors</span>());<br><br>   <span class="hljs-comment">// Your routes and other middleware</span><br><br>   app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server is running on port 3000&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>代理：</strong> 在开发环境中，你可以设置代理，将前端的请求代理到后端，避免跨域问题。例如，在 Vue CLI 或 React 的 Create React App 中，你可以配置 <code>vue.config.js</code> 或 <code>package.json</code> 中的 <code>proxy</code> 字段。</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">   <span class="hljs-comment">// vue.config.js</span><br>   module.exports = <span class="hljs-punctuation">&#123;</span><br>     devServer<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>       proxy<span class="hljs-punctuation">:</span> &#x27;http<span class="hljs-punctuation">:</span><span class="hljs-comment">//localhost:3000&#x27;</span><br>     <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>JSONP（仅限 GET 请求）：</strong> JSONP 是一种通过动态创建 <code>&lt;script&gt;</code> 标签实现跨域请求的方法。不过，它有一些限制，比如仅支持 GET 请求。</p></li><li><p><strong>CORS（跨域资源共享）：</strong> 在正式环境中，可以配置后端支持 CORS，允许特定的域访问资源。这需要后端和前端的配合，确保正确设置跨域请求所需的头信息。</p></li></ul></li></ol><p>Webpack核心概念:loader</p><p>webpack 只能理解JavaScript和JSON文件(其实是Node.js)，这是 webpack 开箱可用的自带能力。loader让webpack能够去处理其他类型的文件，并将它们转换为有效模块，以供应用程序使用，以及被添加到依赖图中。</p><h5 id="React开发"><a href="#React开发" class="headerlink" title="React开发"></a>React开发</h5><p>React是一个用于构建用户界面的JavaScript库，由Facebook开发和维护。它采用组件化的方式构建UI,通过虚拟DOM实现高效的页面更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fuction <span class="hljs-title class_">HelloMessage</span>(props) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>一个简单的React组件用类似上面的代码进行定义<br>一个React组件定义为一个function(组件名建议以大驼峰进行命名)，它接收输入的数据并返回需要展示的内容。<br>在上面return关键字后面的类似XML的写法被称为JSX，被传入的数据在组件中通过props进行访问。</p><p>1．组件化: React将页面拆分成多个组件，每个组件都有自己的状态和生命周期，便于代码的复用和维护。<br>2．虚拟DOM:React通过虚拟DOM实现高效的页面更新，将修改操作转换为虚拟DOM树上的节点操作，然后批量更新DOM，减少了DOM操作的次数，提高了页面性能。</p><p>3.JSX语法: React采用JSX语法，将HTML和JavaScript混合在一起<br>使得代码更加直观和易于理解。<br>4．单向数据流:React采用单向数据流的模式，数据只能从父组件传递到子组件，子组件不能直接修改父组件的数据，保<br>证了数据的可控性。<br>5．生命周期: React组件有生命周期，可以在组件的不同阶段执行相应的操作，比如组件的创建、更新、销毁等。<br>6.组件库: React有丰富的组件库，如Ant Design、Material Ul等，可以快速搭建出漂亮、易于使用的界面。<br>7.社区支持: React有庞大的社区支持，有大量的教程、文档和开源项目可供学习和使用。</p><h5 id="组件与JSX语法"><a href="#组件与JSX语法" class="headerlink" title="组件与JSX语法"></a>组件与JSX语法</h5><p>解构函数</p><p>解构函数是指在函数参数列表中使用解构赋值的语法。这使得你可以从传递给函数的对象或数组中提取值并将其赋给函数的参数，从而更方便地处理和使用这些值。解构函数通常用于简化代码、提高可读性以及方便地使用对象和数组的属性或元素。</p><ul><li>解构对象参数：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 传递对象参数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printUserDetails</span>(<span class="hljs-params">&#123; name, age, email &#125;</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Name: <span class="hljs-subst">$&#123;name&#125;</span>, Age: <span class="hljs-subst">$&#123;age&#125;</span>, Email: <span class="hljs-subst">$&#123;email&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John Doe&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,<br>  <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;john@example.com&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// 调用函数并传递对象参数</span><br><span class="hljs-title function_">printUserDetails</span>(user);<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>printUserDetails</code> 函数的参数使用了对象的解构赋值，直接从传递给函数的 <code>user</code> 对象中提取了 <code>name</code>、<code>age</code> 和 <code>email</code> 属性。</p><ul><li>解构数组参数：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 传递数组参数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printNumbers</span>(<span class="hljs-params">[a, b, c]</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`a: <span class="hljs-subst">$&#123;a&#125;</span>, b: <span class="hljs-subst">$&#123;b&#125;</span>, c: <span class="hljs-subst">$&#123;c&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-comment">// 调用函数并传递数组参数</span><br><span class="hljs-title function_">printNumbers</span>(numbers);<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>printNumbers</code> 函数的参数使用了数组的解构赋值，直接从传递给函数的 <code>numbers</code> 数组中提取了元素。</p><ul><li>默认值和重命名：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 传递带有默认值的对象参数，并使用重命名</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printUserInfo</span>(<span class="hljs-params">&#123; name, age = <span class="hljs-number">30</span>, email: userEmail &#125;</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Name: <span class="hljs-subst">$&#123;name&#125;</span>, Age: <span class="hljs-subst">$&#123;age&#125;</span>, Email: <span class="hljs-subst">$&#123;userEmail&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> userInfo = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;alice@example.com&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// 调用函数并传递对象参数</span><br><span class="hljs-title function_">printUserInfo</span>(userInfo);<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>printUserInfo</code> 函数的参数使用了对象的解构赋值，其中 <code>age</code> 设置了默认值，而 <code>email</code> 被重命名为 <code>userEmail</code>。</p><p>解构函数使得代码更加简洁，并提高了可读性，特别是在处理复杂的对象和数组参数时。这个特性在现代 JavaScript 开发中得到广泛应用。</p><h5 id="JSX语法-列表渲染"><a href="#JSX语法-列表渲染" class="headerlink" title="JSX语法-列表渲染"></a>JSX语法-列表渲染</h5><h5 id="JSX语法-条件渲染"><a href="#JSX语法-条件渲染" class="headerlink" title="JSX语法-条件渲染"></a>JSX语法-条件渲染</h5><h5 id="组件的状态和属性"><a href="#组件的状态和属性" class="headerlink" title="组件的状态和属性"></a>组件的状态和属性</h5><h5 id="组件间传值"><a href="#组件间传值" class="headerlink" title="组件间传值"></a>组件间传值</h5><h5 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h5><p>Hook，又称钩子。是React 16.8的新增属性，它可以让我们在不编写class的情况下使用state以及其他的React特性，Hook就相当于添加了内部状态的函数式组件，Hook已经目前前端的主流开发方式，Vue3中也引入了类似的特性，在后面的项目中我们会全面使用Hook。</p><ul><li>Hook相对于之前的Class写法有以下几点好处:</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-number">1.</span>更简单的复用组件的内部逻辑以及状态<br><span class="hljs-number">2.</span>简单的生命周期逻辑<br><span class="hljs-number">3.</span>无需使用<span class="hljs-keyword">class</span><br></code></pre></td></tr></table></figure><p>Hook就是可以让你在函数式组件内部“钩入”React state以及生命周期等特性的函数，Hook 不能在类组件中使用。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">useState</span><br><span class="hljs-attribute">useEffect</span><br><span class="hljs-attribute">useRef</span><br><span class="hljs-attribute">useCallback</span><br><span class="hljs-attribute">useMemo</span><br></code></pre></td></tr></table></figure><h5 id="全栈开发基础"><a href="#全栈开发基础" class="headerlink" title="全栈开发基础"></a>全栈开发基础</h5><p>01 Http协议<br>02Node.js基础<br>03 Node.js常见模块</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">fs</span>模块(<span class="hljs-built_in">fs</span>-extra模块)<br><span class="hljs-built_in">path</span>模块<br>http模块<br>child process模块<br>os模块<br>cluster模块<br>cross-env模块，axios模块,dateFormat模块<br></code></pre></td></tr></table></figure><h5 id="Koa模块介绍"><a href="#Koa模块介绍" class="headerlink" title="Koa模块介绍"></a>Koa模块介绍</h5><ul><li>为什么要用框架</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">Node.js原生http功能过于基础<br>路由<span class="hljs-regexp">/缓存/</span>cookie<span class="hljs-regexp">/http头/</span>状态码/静态文件等各种功能没有<br></code></pre></td></tr></table></figure><ul><li>常用web开发框架</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">express/koa同一个团队开发<br>Egg<span class="hljs-number">.</span><span class="hljs-keyword">js</span> 基于koa,约定优于配置,多进程模型<br>NestJS基于express,高效可扩展的Node<span class="hljs-number">.</span><span class="hljs-keyword">js</span>服务端框架。对ts支持比较好。<br>Next<span class="hljs-number">.</span><span class="hljs-keyword">js</span>/Nuxt<span class="hljs-number">.</span><span class="hljs-keyword">js</span> 基于React/Vue的SSR开发框架<br></code></pre></td></tr></table></figure><ul><li>Koa模块介绍</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">App:</span>应用<br><span class="hljs-symbol">Context:</span>处理http请求上下文<br><span class="hljs-symbol">Request:</span>请求<br><span class="hljs-symbol">Response:</span>响应<br></code></pre></td></tr></table></figure><h5 id="前端面试"><a href="#前端面试" class="headerlink" title="前端面试"></a>前端面试</h5><p><a href="https://zhuanlan.zhihu.com/p/605933425"></a></p><h4 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h4><p>一些json，渲染，内置组件，api。</p><p><a href="https://blog.csdn.net/m0_64875238/article/details/127796691">https://blog.csdn.net/m0_64875238/article/details/127796691</a></p><h4 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h4><p>AppDelegate.swift文件</p><p>ViewController.swift 视图控制器</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>密码</title>
    <link href="/2024/04/23/%E5%AF%86%E7%A0%81/"/>
    <url>/2024/04/23/%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>2024-04-23 重装数据库 密码root</p><p>rdsmysql 密码Qw!08070908 3个月后手动释放资源 防止扣费</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo配置</title>
    <link href="/2024/01/26/hexo%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/01/26/hexo%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>[官网手册](<a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97">https://fluid-dev.github.io/hexo-fluid-docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97</a></p><p>#####)</p><h5 id="更改主页照片"><a href="#更改主页照片" class="headerlink" title="更改主页照片"></a>更改主页照片</h5><p>更改_config.fluid.yml里面的</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">今天莫名hexo d报错：ssh: <span class="hljs-keyword">connect</span> <span class="hljs-keyword">to</span> host github.com port <span class="hljs-number">22</span>: <span class="hljs-keyword">Connection</span> timed <span class="hljs-keyword">out</span> fatal: Could <span class="hljs-keyword">not</span> <span class="hljs-keyword">read</span> <span class="hljs-keyword">from</span> remote repository.<br>尝试删除ssh密钥重新配置，大小写是否错误等还是不行<br><br>ssh -T git@github.com 也报错<br><br>最后解决方案：https://blog.csdn.net/nightwishh/article/details/<span class="hljs-number">99647545</span><br>在.ssh文件下面创建vim config<br>输入：<br>Host github.com<br><span class="hljs-keyword">User</span> 注册github的邮箱<br>Hostname ssh.github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa<br>Port <span class="hljs-number">443</span><br><br><br></code></pre></td></tr></table></figure><h5 id="基本操作语句"><a href="#基本操作语句" class="headerlink" title="基本操作语句"></a>基本操作语句</h5><p>在D:\myblog\hexo目录 git bash here</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;name&quot;</span>       <span class="hljs-meta"># 新建文章</span><br>hexo <span class="hljs-keyword">new</span> page <span class="hljs-string">&quot;name&quot;</span>  <span class="hljs-meta"># 新建页面</span><br>hexo g                <span class="hljs-meta"># 生成页面</span><br>hexo d                <span class="hljs-meta"># 部署</span><br>hexo g -d             <span class="hljs-meta"># 生成页面并部署</span><br>hexo s                <span class="hljs-meta"># 本地预览</span><br>hexo clean            <span class="hljs-meta"># 清除缓存和已生成的静态文件</span><br>hexo help             <span class="hljs-meta"># 帮助</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法学习</title>
    <link href="/2024/01/24/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/01/24/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h2><h3 id="基础算法-——-代码模板链接"><a href="#基础算法-——-代码模板链接" class="headerlink" title="基础算法 —— 代码模板链接"></a>基础算法 —— 代码模板链接</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++">我会联想动态的图来记忆。<br>    <br>选择 插入 （有点类似打扑克抓牌，慢）<br>冒泡 堆 <br>归并（分治、递归）  快速（分治、选基准元素）<br><br><span class="hljs-number">1.</span> **冒泡排序（Bubble Sort）**：<br>   - 稳定性：稳定<br>   - 时间复杂度：平均情况和最坏情况均为<span class="hljs-built_in">O</span>(n^<span class="hljs-number">2</span>)<br>   - 空间复杂度：<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<br>   - 主要特点：相邻元素两两比较，若逆序则交换。<br><br><span class="hljs-number">2.</span> **选择排序（Selection Sort）**：<br>   - 稳定性：不稳定<br>   - 时间复杂度：平均情况和最坏情况均为<span class="hljs-built_in">O</span>(n^<span class="hljs-number">2</span>)<br>   - 空间复杂度：<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<br>   - 主要特点：每次选择未排序部分的最小元素，放到已排序部分的末尾。<br><br><span class="hljs-number">3.</span> **插入排序（Insertion Sort）**：<br>   - 稳定性：稳定<br>   - 时间复杂度：平均情况和最坏情况均为<span class="hljs-built_in">O</span>(n^<span class="hljs-number">2</span>)<br>   - 空间复杂度：<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<br>   - 主要特点：将元素逐个插入到已排序的部分，构建有序序列。<br><br><span class="hljs-number">4.</span> **快速排序（Quick Sort）**：<br>   - 稳定性：不稳定<br>   - 时间复杂度：平均情况为<span class="hljs-built_in">O</span>(nlogn)，最坏情况为<span class="hljs-built_in">O</span>(n^<span class="hljs-number">2</span>)<br>   - 空间复杂度：平均情况为<span class="hljs-built_in">O</span>(logn)，最坏情况为<span class="hljs-built_in">O</span>(n)<br>   - 主要特点：采用分治法，通过选取基准元素将数组分为两部分，然后递归地对子数组进行排序。<br><br><span class="hljs-number">5.</span> **归并排序（Merge Sort）**：<br>   - 稳定性：稳定<br>   - 时间复杂度：平均情况和最坏情况均为<span class="hljs-built_in">O</span>(nlogn)<br>   - 空间复杂度：<span class="hljs-built_in">O</span>(n)<br>   - 主要特点：采用分治法，将数组分成两个子数组，分别排序后再合并。<br><br><span class="hljs-number">6.</span> **堆排序（Heap Sort）**：<br>   - 稳定性：不稳定<br>   - 时间复杂度：平均情况和最坏情况均为<span class="hljs-built_in">O</span>(nlogn)<br>   - 空间复杂度：<span class="hljs-built_in">O</span>(<span class="hljs-number">1</span>)<br>   - 主要特点：利用堆数据结构，将数组构建成最大堆（最小堆），然后依次取出堆顶元素。<br><br>    <br><span class="hljs-comment">/*快速排序算法模板 —— 模板题 AcWing 785. 快速排序</span><br><span class="hljs-comment">分治</span><br><span class="hljs-comment">1、确定分界点 左 中 右</span><br><span class="hljs-comment">2、调整区间</span><br><span class="hljs-comment">3、递归处理左右两段</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j), <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br><br>归并排序算法模板 —— 模板题 AcWing <span class="hljs-number">787.</span> 归并排序<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(q, l, mid);<br>    <span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span> tmp[k ++ ] = q[j ++ ];<br><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];<br><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C++">整数二分算法模板 —— 模板题 AcWing <span class="hljs-number">789.</span> 数的范围<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><span class="hljs-comment">// 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br>浮点数二分算法模板 —— 模板题 AcWing <span class="hljs-number">790.</span> 数的三次方根<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; eps)<br>    &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><p>高精度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs C++">高精度加法 —— 模板题 AcWing <span class="hljs-number">791.</span> 高精度加法<br><span class="hljs-comment">// C = A + B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() &lt; B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(B, A);<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (t) C.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br>高精度减法 —— 模板题 AcWing <span class="hljs-number">792.</span> 高精度减法<br><span class="hljs-comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br>高精度乘低精度 —— 模板题 AcWing <span class="hljs-number">793.</span> 高精度乘法<br><span class="hljs-comment">// C = A * b, A &gt;= 0, b &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || t; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i] * b;<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br>高精度除以低精度 —— 模板题 AcWing <span class="hljs-number">794.</span> 高精度除法<br><span class="hljs-comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;r)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r / b);<br>        r %= b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><p>前缀和与差分</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">一维前缀和 —— 模板题 AcWing <span class="hljs-number">795.</span> 前缀和<br>S[i] = a[<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>] + ... a[i]<br>a[l] + ... + a[r] = S[r] - S[l - <span class="hljs-number">1</span>]<br>二维前缀和 —— 模板题 AcWing <span class="hljs-number">796.</span> 子矩阵的和<br>S[i, j] = 第i行j列格子左上部分所有元素的和<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - <span class="hljs-number">1</span>, y2] - S[x2, y1 - <span class="hljs-number">1</span>] + S[x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>]<br>一维差分 —— 模板题 AcWing <span class="hljs-number">797.</span> 差分<br>给区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="hljs-number">1</span>] -= c<br>二维差分 —— 模板题 AcWing <span class="hljs-number">798.</span> 差分矩阵<br>给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] += c, S[x2 + <span class="hljs-number">1</span>, y1] -= c, S[x1, y2 + <span class="hljs-number">1</span>] -= c, S[x2 + <span class="hljs-number">1</span>, y2 + <span class="hljs-number">1</span>] += c<br></code></pre></td></tr></table></figure><p>双指针算法<br>位运算</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">位运算 —— 模板题 AcWing <span class="hljs-number">801.</span> 二进制中<span class="hljs-number">1</span>的个数<br>求n的第k位数字: n &gt;&gt; k &amp; <span class="hljs-number">1</span><br>返回n的最后一位<span class="hljs-number">1</span>：<span class="hljs-built_in">lowbit</span>(n) = n &amp; -n<br>双指针算法 —— 模板题 AcWIng <span class="hljs-number">799.</span> 最长连续不重复子序列, AcWing <span class="hljs-number">800.</span> 数组元素的目标和<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j ++ ;<br><br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br>常见问题分类：<br>    (<span class="hljs-number">1</span>) 对于一个序列，用两个指针维护一段区间<br>    (<span class="hljs-number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作<br></code></pre></td></tr></table></figure><p>离散化</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">离散化 —— 模板题 AcWing <span class="hljs-number">802.</span> 区间和<br>vector&lt;<span class="hljs-type">int</span>&gt; alls; <span class="hljs-comment">// 存储所有待离散化的值</span><br><span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将所有值排序</span><br>alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()), alls.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">// 去掉重复元素</span><br><br><span class="hljs-comment">// 二分求出x对应的离散化的值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 找到第一个大于等于x的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 映射到1, 2, ...n</span><br>&#125;<br></code></pre></td></tr></table></figure><p>区间合并</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">区间合并 —— 模板题 AcWing <span class="hljs-number">803.</span> 区间合并<br><span class="hljs-comment">// 将所有存在交集的区间合并</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;PII&gt; &amp;segs)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;PII&gt; res;<br><br>    <span class="hljs-built_in">sort</span>(segs.<span class="hljs-built_in">begin</span>(), segs.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-type">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs)<br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>            st = seg.first, ed = seg.second;<br>        &#125;<br>        <span class="hljs-keyword">else</span> ed = <span class="hljs-built_in">max</span>(ed, seg.second);<br><br>    <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br><br>    segs = res;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="数据结构-——-代码模板链接-常用代码模板2——数据结构"><a href="#数据结构-——-代码模板链接-常用代码模板2——数据结构" class="headerlink" title="数据结构 —— 代码模板链接 常用代码模板2——数据结构"></a>数据结构 —— 代码模板链接 常用代码模板2——数据结构</h3><p>链表与邻接表：树与图的存储<br>栈与队列：单调队列、单调栈<br>kmp<br>Trie<br>并查集<br>堆<br>Hash表</p><h5 id="搜索与图论-——-代码模板链接-常用代码模板3——搜索与图论"><a href="#搜索与图论-——-代码模板链接-常用代码模板3——搜索与图论" class="headerlink" title="搜索与图论 —— 代码模板链接 常用代码模板3——搜索与图论"></a>搜索与图论 —— 代码模板链接 常用代码模板3——搜索与图论</h5><p>DFS与BFS<br>树与图的遍历：拓扑排序<br>最短路<br>最小生成树<br>二分图：染色法、匈牙利算法</p><h5 id="数学知识-——-代码模板链接-常用代码模板4——数学知识"><a href="#数学知识-——-代码模板链接-常用代码模板4——数学知识" class="headerlink" title="数学知识 —— 代码模板链接 常用代码模板4——数学知识"></a>数学知识 —— 代码模板链接 常用代码模板4——数学知识</h5><p>质数<br>约数<br>欧拉函数<br>快速幂<br>扩展欧几里得算法<br>中国剩余定理<br>高斯消元<br>组合计数<br>容斥原理<br>简单博弈论</p><h5 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h5><p>背包问题<br>线性DP<br>区间DP<br>计数类DP<br>数位统计DP<br>状态压缩DP<br>树形DP<br>记忆化搜索</p><h5 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h5><h5 id="时空复杂度分析"><a href="#时空复杂度分析" class="headerlink" title="时空复杂度分析"></a>时空复杂度分析</h5>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>zotero插件安装</title>
    <link href="/2024/01/06/zotero%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    <url>/2024/01/06/zotero%E6%8F%92%E4%BB%B6%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<p><a href="https://imgse.com/i/pizCAII"><img src="https://s11.ax1x.com/2024/01/06/pizCAII.png" alt="pizCAII.png"></a></p><p>注意事项：</p><ul><li><p>zotero版本可能与插件不匹配，可以调整插件或zotero版本</p></li><li><p>gtp插件使用时，不能开梯子</p></li><li><p>gtp插件快捷键 Ctrl+&#x2F; 退出Esc</p></li><li><p>全文翻译 用到zotero-style是需要调用PDF Translate 和Better Notes 才能实现全文翻译，匹配zetero 6 的zotero-style， 快捷键Shift+P，</p></li><li></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓项目开发</title>
    <link href="/2023/12/26/%E5%AE%89%E5%8D%93%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    <url>/2023/12/26/%E5%AE%89%E5%8D%93%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h3 id="项目练习"><a href="#项目练习" class="headerlink" title="项目练习"></a>项目练习</h3><p><a href="https://blog.csdn.net/qq_42257666/article/details/117952517"></a></p><h6 id="项目1-通讯录"><a href="#项目1-通讯录" class="headerlink" title="项目1 通讯录"></a>项目1 通讯录</h6><ol><li>在activity.xml写好布局</li><li>创建4个Actiivity，写好布局</li><li>查找按钮，按钮设置监听，重写点击方法，新建intent，startActivity</li><li>新建MyHelper.java 写入数据库相关语句</li><li>在对应的界面，实例化myHelper，设置监听，进行数据库数据库。</li></ol><p>TIPS：</p><ul><li>布局design完毕 点一下魔术棒</li><li>Toast没有显示，模拟器wipe data</li><li>布局文件design无法加载 查看发现是插件不匹配，在C盘找到相应文件，删除</li></ul><h6 id="项目2-记事本"><a href="#项目2-记事本" class="headerlink" title="项目2 记事本"></a>项目2 记事本</h6><p>记事本有很多条目，布局相同，内容属性相同</p><ol><li><p>创建记事本列表界面Item</p></li><li><p>封装记录信息实体类NotepadBean</p></li><li><p>编写记事本列表适配器NotepadAdapter，使用ListView展示</p><ul><li>创建NotepadAdapter类</li><li>创建ViewHolder类</li></ul><p>listview里面放置adapter,adapter里面放置item</p></li><li><p>创建数据库</p></li><li></li></ol><h6 id=""><a href="#" class="headerlink" title=""></a></h6><h3 id="毕设"><a href="#毕设" class="headerlink" title="毕设"></a>毕设</h3><h4 id="必备睡眠相关知识"><a href="#必备睡眠相关知识" class="headerlink" title="必备睡眠相关知识"></a>必备睡眠相关知识</h4><ul><li><p>PER蛋白阻断了“周期基因”的活性，并认为通过抑制反馈回路，PER蛋白可以阻止其自身的合成，从而已连续的循环节律调节自身的蛋白水平。</p></li><li><p>人类的生物钟系统是怎样的？</p></li></ul><p>一个能够产生生理性昼夜节律活动的生物钟系统，包括以下三部分：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">光感受器——&gt;时钟——&gt;输出通路<br>视网膜——&gt;节细胞视交叉上核<span class="hljs-comment">(SCN)</span>——&gt;下丘脑<br></code></pre></td></tr></table></figure><ul><li><p>人体中枢生物钟系统</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">•</span> <span class="hljs-type">SCN</span>——视交叉上核；<br><span class="hljs-operator">•</span> <span class="hljs-type">Kidney</span>——肾脏；<br><span class="hljs-operator">•</span> <span class="hljs-type">ACTH</span>——促肾上腺皮质激素；<br><span class="hljs-operator">•</span> <span class="hljs-type">Adrenal</span>——肾上腺<br><span class="hljs-operator">•</span> <span class="hljs-type">Cort</span>——皮质醇<br><span class="hljs-operator">•</span> <span class="hljs-type">HPA</span> axis——下丘脑<span class="hljs-operator">-</span>垂体<span class="hljs-operator">-</span>肾上腺轴<br><span class="hljs-operator">•</span> <span class="hljs-type">PIT</span>——垂体<br><span class="hljs-operator">•</span> 松果体有节奏地产生褪黑激素，它调节睡眠<span class="hljs-operator">/</span>觉醒周期（黄色）<span class="hljs-operator">。</span><br><span class="hljs-operator">•</span> 垂体（<span class="hljs-type">PIT）释放ACTH（绿色）会控制肾上腺（adrenal）有节奏地产生皮质醇（Cort），形成HPA轴</span><span class="hljs-operator">。</span><br><span class="hljs-operator">•</span> 皮质醇充当外周器官的同步器和<span class="hljs-type">SCN节律性的稳定剂</span><span class="hljs-operator">。</span><br></code></pre></td></tr></table></figure></li><li><p>节律调节系统最重要的核心是光照，运用好光照来进行节律的调节是最重要的</p></li><li><p>睡眠压力（Sleep Pressure）也是决定个体白天灵敏性及夜晚睡眠状态的因素之一，是化学物质腺苷，又称嗜睡化学物质在大脑中的积聚，其积聚越多，个体越困倦。</p></li><li><p>去甲肾上腺素同时有神经递质和荷尔蒙的身份，它是有名的“压力”荷尔蒙，同时也是“打或跑”决断中起主要作用的物质。去甲肾上腺素有助清醒。</p></li><li><p>睡眠-觉醒循环</p></li><li><p>睡眠的定义与阶段划分</p></li></ul><p>Non-Rapid Eye Movement（NREM），Rapid Eye Movement（REM）</p><ul><li><strong>多导睡眠监测(Polysomnography)</strong></li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">Poly</span> <span class="hljs-operator">=</span> refers to recording of many different parameters<br><span class="hljs-attribute">Somno</span> <span class="hljs-operator">=</span> relating to sleep<br><span class="hljs-attribute">Graphy</span> <span class="hljs-operator">=</span> charting of recording parameters.<br></code></pre></td></tr></table></figure><p><strong>PSG****采集系统组成</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">体表 电极 采集盒 放大器 计算机 显示器<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">PSG同时监测下列多个生理信号:<br>Brain <span class="hljs-type">wave</span> <span class="hljs-variable">activity</span> <span class="hljs-operator">=</span> electroencephalogram (EEG) 脑电图<br><span class="hljs-type">Eye</span> <span class="hljs-variable">movements</span> <span class="hljs-operator">=</span> electro-oculogram (EOG) 眼电图<br><span class="hljs-type">Muscle</span> <span class="hljs-variable">activity</span> <span class="hljs-operator">=</span> electromyogram (EMG) including: 肌电图<br>Chin <span class="hljs-title function_">muscle</span> <span class="hljs-params">(submentalis)</span> activity 呼吸气流<br>Leg muscle activity <br>Arm muscle <span class="hljs-title function_">activity</span> <span class="hljs-params">(in certain circumstances)</span> <br>Airflow 血氧饱和度<br>Respiratory activity of chest and abdomen <br>Heart rate <span class="hljs-type">and</span> <span class="hljs-variable">rhythm</span> <span class="hljs-operator">=</span> electrocardiogram (EKG or ECG) 胸腹呼吸活动<br>Oxygen saturation=pulse <span class="hljs-title function_">oximetry</span> <span class="hljs-params">(SaO2)</span> 心电图<br><span class="hljs-type">Carbon</span> <span class="hljs-variable">dioxide</span> <span class="hljs-operator">=</span> end-tidal or transcutaneous CO2 呼末或经皮CO2<br></code></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gcode">睡眠呼吸监测装置分级<span class="hljs-comment">(AASM)</span><br>I级，标准多导睡眠监测仪<br><span class="hljs-comment">(Standard polysomnography)</span><br>II级，全指标便携式多导睡眠监测仪<br><span class="hljs-comment">(Comprehensive portable polysomnography)</span><br>II级，改良便携式睡眠呼吸暂停检查<br><span class="hljs-comment">(Modified portable sleep apnea testing)</span><br>IV级，单或双生物指标持续记录<br><span class="hljs-comment">(Continuous single or dual bioparameters)</span><br></code></pre></td></tr></table></figure><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">睡眠时序图<br>• 睡眠总时间：<span class="hljs-keyword">TST</span><br>• 睡眠效率：<span class="hljs-keyword">TST</span>/熄灯到开灯时间<br>• N1，N2，SWS，REM阶段占比：/<span class="hljs-keyword">TST</span><br>• 睡眠延迟：SOL，熄灯到入睡<br>• 睡眠后清醒时间：WASO<br>• REM延迟：REML<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown">有哪些睡眠特征（频率）：<br><span class="hljs-bullet">1.</span> β 大于13Hz、<br><span class="hljs-bullet">2.</span> α 8-13Hz、<br><span class="hljs-bullet">3.</span> θ 4-7.9Hz、<br><span class="hljs-bullet">4.</span> δ 0.5-3.9Hz（慢波睡眠中δ 频率通常在0.5-2Hz）<br><br>• 有哪些睡眠特征（波形事件）：<br><span class="hljs-bullet">2.</span> 慢波（N3）、K复合波（N2）、纺锤波（N2 or N3）、锯齿波（REM）<br><span class="hljs-bullet">3.</span> 快速眼动（REM）、慢眼动（W、N1）<br><span class="hljs-bullet">4.</span> 肌电活动幅度（REM＜N3＜N2＜N1=W）<br><span class="hljs-bullet">5.</span> 大体动（没醒）、微觉醒（小于15秒的短醒）<br></code></pre></td></tr></table></figure><p><a href="https://imgse.com/i/piyifSI"><img src="https://z1.ax1x.com/2023/12/03/piyifSI.png" alt="piyifSI.png"></a></p><ul><li>非快速眼动睡眠N2阶段的标志；学习记忆等多种认知功能密切相关；</li><li>纺锤波活动的异常与精神分裂等众多精神类疾病的发病有关。</li><li>纺锤波检测</li><li>摇摆刺激可以<strong>缩短入睡时间</strong>和<strong>加强深度睡眠</strong></li></ul><h4 id="毕设需求分析"><a href="#毕设需求分析" class="headerlink" title="毕设需求分析"></a>毕设需求分析</h4><p>app通过蓝牙连接能控制硬件设备在准备入睡的时候开始采集数据，硬件设备采集的数据存储sd卡中。<br>早上某个时间自动或者通过app操作手动的把数据上传到云端。云端有算法，能对数据进行分析，然后把一部分结果返回到app上显示。</p><p>如果有的文章是从app直接传数据到云端我们也是需要的。因为一些睡眠相关的量表等主观信息也是需要从app直接传到云端的。app通过蓝牙控制设备这部分论文里应该会提到。<br>如果没提到我们自己的设备是有这个功能的。后面把设备寄给你，程序拷给你。至于数据从硬件的SD卡里具体如何传输到云端，可能你要看一下论文里有没有，或者按这个需求自己查一下资料</p><h5 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h5><ul><li><p><input disabled="" type="checkbox"> 通过蓝牙连接能控制硬件设备，采集数据</p></li><li><p><input disabled="" type="checkbox"> app操作手动的把数据上传到云端</p></li><li><p><input disabled="" type="checkbox"> 数据分析结果返回到app上显示</p></li><li><p><input disabled="" type="checkbox"> app直接传数据到云端 or 数据从硬件的SD卡里具体如何传输到云端</p></li><li><p><input disabled="" type="checkbox"> 睡眠实时监测</p></li><li><p><input disabled="" type="checkbox"> 历史查询</p></li><li><p><input disabled="" type="checkbox"> 个人中心</p></li><li><p><input disabled="" type="checkbox"> 睡眠评分模块</p></li><li><p><input disabled="" type="checkbox"> 睡眠建议及睡眠历史记录模块</p></li><li><p><input disabled="" type="checkbox"> 睡眠知识与个人设置模块</p></li><li><p><input disabled="" type="checkbox"> 环境及生理参数模块与个人设置模块</p></li></ul><p>前后端分离，后端和数据库部署云。</p><p>数据库：3张表，后端映射操作数据库。</p><h5 id="文件整理"><a href="#文件整理" class="headerlink" title="文件整理"></a>文件整理</h5><img src="D:\pic\typora_pic\image-20240717101536878.png" alt="image-20240717101536878" style="zoom:50%;" /><h6 id="today"><a href="#today" class="headerlink" title="today"></a>today</h6><p>CustomClockView.kt 自定义组件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> viewScope = CoroutineScope(Dispatchers.Main + Job())<br><span class="hljs-comment">//Dispatchers.Main + Job() 创建了一个新的协程作用域，该作用域在主线程上运行，并且拥有自己的作业管理。所有在这个作用域内启动的协程都将与这个作业关联，当作业被取消时，这些协程也会被取消。</span><br></code></pre></td></tr></table></figure><h6 id="clock"><a href="#clock" class="headerlink" title="clock"></a>clock</h6><p>SleepConsistencyView.kt 自定义组件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">val avgSleepStartTop = (height * (averageSleepStartTime.<span class="hljs-built_in">get</span>(Calendar.HOUR_OF_DAY) + averageSleepStartTime.<span class="hljs-built_in">get</span>(Calendar.MINUTE) / 60f)) / 24<br>        val avgSleepEndTop = (height * (averageSleepEndTime.<span class="hljs-built_in">get</span>(Calendar.HOUR_OF_DAY) + averageSleepEndTime.<span class="hljs-built_in">get</span>(Calendar.MINUTE) / 60f)) / 24<br><br></code></pre></td></tr></table></figure><h5 id="更新迭代"><a href="#更新迭代" class="headerlink" title="更新迭代"></a>更新迭代</h5><ul><li><input checked="" disabled="" type="checkbox"> 改四个角</li><li><input checked="" disabled="" type="checkbox"> 增加睡眠一致性 改成时间戳 改为过去所有星期的平均</li><li><input checked="" disabled="" type="checkbox"> 视图销毁,释放资源</li><li><input disabled="" type="checkbox"> 修复history页面</li><li><input disabled="" type="checkbox"> 改数据库</li><li><input disabled="" type="checkbox"> 增加雷达图</li></ul><p>使用平均时间戳计算平均时间的纵坐标位置有问题，应该从平均时间戳直接转化为年月日时间，从中提取小时、分钟和秒后，最后映射到纵坐标上</p><ul><li>ThreadLocal</li></ul><p>总的来说，ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景。<br>ThreadLocal和Synchonized都用于解决多线程并发访问。但是ThreadLocal与synchronized有本质的区别：<br>1、Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。<br>2、Synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。而Synchronized却正好相反，它用于在多个线程间通信时能够获得数据共享。</p><ul><li><p>协程 lifecycleScope</p></li><li><p><code>onDestroyView()</code>: 当 Fragment 的视图层次结构（View hierarchy）被销毁时调用。这通常发生在 Fragment 被移除或替换时，但 Fragment 本身并未被销毁。例如，当一个 Fragment 被添加到回退栈并随后恢复时，<code>onDestroyView()</code> 会被调用，但 <code>onDestroy()</code> 不会。</p><p><code>onDestroy()</code>: 当 Fragment 本身被销毁时调用。此方法是 Fragment 生命周期的最后一步。在这一步，所有的资源都应该被清理干净。一般在 Fragment 不会再使用时调用。</p><p>在 <code>onPause()</code> 中取消正在进行的请求，可以确保在用户离开当前 Fragment 时停止不必要的网络操作，以提高应用性能和用户体验。</p></li><li><p>RetrofitClient和OkHttp</p></li></ul><p>网络请求的工作本质上是 OkHttp 完成，而 Retrofit 仅负责网络请求接口的封装。</p><p>产品介绍：</p><p>全面可靠的公司团队，有硬件产品，配套的软件，形成的系统，干预设备。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>吉他</title>
    <link href="/2023/12/18/%E5%90%89%E4%BB%96/"/>
    <url>/2023/12/18/%E5%90%89%E4%BB%96/</url>
    
    <content type="html"><![CDATA[<h5 id="简谱"><a href="#简谱" class="headerlink" title="简谱"></a>简谱</h5><p>do re mi fa so la si</p><p>音符：1—（全），1-(二分），1(四分)，1下面1条线(八分)，1下面2条线(十六分)</p><p>增时线，</p><p>附点：1&#96;(单),1&#96;&#96;(双)，<strong>只能用于小于4分音符往下</strong>。</p><p>休止符：0000,00,0,<strong>不能用于增时线</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>外语入门学习</title>
    <link href="/2023/12/08/%E5%A4%96%E8%AF%AD%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/12/08/%E5%A4%96%E8%AF%AD%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h4 id="法语"><a href="#法语" class="headerlink" title="法语"></a>法语</h4><h5 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h5><p>印欧语罗曼语族 世界第5大语言</p><p>法语字母表：</p><p><a href="https://imgse.com/i/pi2uU5n"><img src="https://z1.ax1x.com/2023/12/08/pi2uU5n.png" alt="pi2uU5n.png"></a></p><ul><li>音素是最小的语音单位</li><li>法语共有36个音素，16个元音音素，17个辅音音素</li><li>法语的元音字母：AEIOUY</li><li>音标：salut [saly] merci[mεrsi]</li></ul><h4 id="韩语"><a href="#韩语" class="headerlink" title="韩语"></a>韩语</h4><p> 表音文字<br>19个辅音+21个元音<br>辅音：松音 紧音 送气音 无归属<br>ㄱㄷㅂㅅㅊ</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深度学习</title>
    <link href="/2023/11/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/11/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h4 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h4><p><strong>监督学习</strong></p><p>包括决策树、<a href="https://www.zhihu.com/search?q=%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%223148635456%22%7D">朴素贝叶斯</a>、SVM、<a href="https://www.zhihu.com/search?q=k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%223148635456%22%7D">k近邻算法</a>、AdaBoost；回归算法：线性回归，<a href="https://www.zhihu.com/search?q=%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%223148635456%22%7D">逻辑回归</a></p><p><strong>非监督学习</strong></p><p><a href="https://www.zhihu.com/search?q=%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%223148635456%22%7D">聚类算法</a>，比如 K-Means、<a href="https://www.zhihu.com/search?q=%E6%9C%80%E5%A4%A7%E6%9C%9F%E6%9C%9B%E7%AE%97%E6%B3%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%223148635456%22%7D">最大期望算法</a> EM</p><p><strong>半监督学习</strong></p><p><strong>强化学习</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Springboot速成</title>
    <link href="/2023/11/30/Springboot%E9%80%9F%E6%88%90/"/>
    <url>/2023/11/30/Springboot%E9%80%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="JAVA速成"><a href="#JAVA速成" class="headerlink" title="JAVA速成"></a>JAVA速成</h3><p><a href="https://blog.csdn.net/qq_43546721/article/details/131550605">https://blog.csdn.net/qq_43546721/article/details/131550605</a></p><h5 id="阶段一-Java基础加提升"><a href="#阶段一-Java基础加提升" class="headerlink" title="阶段一:Java基础加提升"></a>阶段一:Java基础加提升</h5><p>1、Java入门<br>2、基础必知<br>3、流程控制<br>4、面向对象</p><ul><li>类与对象</li><li>构造方法重写</li><li>static、super</li><li>封装、继承、多态</li><li>抽象类、接口</li></ul><p>5、异常处理<br>6、集合框架</p><ul><li>ArrayList、LinkedList</li><li>HashSet、TreeSet</li><li>HashMap、TreeMap</li><li>掌握泛型的应用</li></ul><p>7、常用类</p><ul><li>Object、String</li><li>StringBuilder</li><li>System</li><li>Date、DateFormat</li><li>BigDecimal</li><li>Scanner、Random</li></ul><p>8、<strong>多线程</strong></p><ul><li>进程与线程的关系</li><li>Thread、Runnable</li><li>线程安全、线程同步</li><li>线程状态转换</li><li>线程的生命周期</li><li>线程让步、线程锁、线程池</li></ul><p>9、IO流</p><h5 id="阶段二-JavaWeb阶段"><a href="#阶段二-JavaWeb阶段" class="headerlink" title="阶段二:JavaWeb阶段"></a>阶段二:JavaWeb阶段</h5><p>1、前端基础<br>2、数据库基础<br>3、JDBC<br>4、<strong>Maven</strong><br>5、<strong>MyBatis</strong><br>6、XML<br>7、Tomcat服务器<br>8、Servlet</p><ul><li>Servlet的生命周期</li><li>Servlet常用类和接口</li><li>Servlet体系结构</li><li>urlPattern配置和XML配置</li><li>JSP的概念和动作指令</li></ul><p>9、JSP</p><ul><li>JSP的概念和动作指令</li><li>JSP原理</li><li>JSP九大内置对象<ul><li>request、response、session、application、out、pagecontext、config、page、exception</li></ul></li><li>JSP四大域对象</li><li>增删改查分页操作</li><li>文件上传下载监听器和过滤器</li><li>Cookie和Session</li></ul><p>10、AJAX</p><ul><li>了解AJAX JSON</li><li>xmlHttpRequest对象</li><li>jQuery和Ajax</li></ul><h5 id="阶段三-Spring全家桶"><a href="#阶段三-Spring全家桶" class="headerlink" title="阶段三:Spring全家桶"></a>阶段三:Spring全家桶</h5><p>1、Spring</p><ul><li>spring历史及架构体系</li><li>IOC、DI配置</li><li>装配bean(三种方式)</li><li>作用域和生命周期</li><li>注解开发、元注解</li><li>动态代理机制</li><li>aop xml与注解方式</li><li>AspectJ6种通知</li><li>JdbcTemplate</li></ul><p>2、SpringMVC</p><ul><li>SpringMVC简介原理</li><li>SpringMVC入门程序</li><li>处理器映射器、适配器</li><li>注解开发RequestMapping详解</li><li>基础数据类型</li><li>对象、数组、集合</li><li>参数传递</li><li>包装对象、乱码解决</li><li>CRUD案例转发和重定向</li><li>了解Restfull风格</li><li>SpringMVC国际化</li></ul><p>3、MyBaits</p><ul><li>MyBatis开发方式</li><li>Mapper.xml常用配置</li><li>单表查询</li><li>parmterType和resultType</li><li>多表关联查询</li><li>MyBatis逆向工程</li><li>MyBatis缓存</li><li>MyBatis动态SQL</li></ul><p>4、SpringBoot</p><ul><li>SpringBoot概述和入门</li><li>SpringBoot容器功能</li><li>SpringBoot日志</li><li>数据响应与内容协商</li><li>视图解析与模板引擎</li><li>各种框架整合</li></ul><h5 id="阶段四-分布式微服务架构"><a href="#阶段四-分布式微服务架构" class="headerlink" title="阶段四:分布式微服务架构"></a>阶段四:分布式微服务架构</h5><p>1、微服务架构：学习微服务的概念、原则和优势，了解如何将应用程序拆分成小型、自治的服务。</p><p>2、服务注册与发现：学习使用服务注册与发现工具（如Eureka、Consul）管理微服务的注册、发现和负载均衡。</p><p>3、服务通信：学习使用轻量级的通信协议（如REST、gRPC）实现微服务之间的通信，了解消息队列和事件驱动架构。</p><p>4、容器化和编排：学习使用Docker等容器技术打包和部署微服务，使用Kubernetes等容器编排工具管理容器化应用程序。</p><p>5、分布式数据管理：学习处理分布式数据存储和一致性问题，了解数据库拆分、分布式缓存和分布式事务的解决方案。</p><h5 id="阶段五：技能深入提升"><a href="#阶段五：技能深入提升" class="headerlink" title="阶段五：技能深入提升"></a>阶段五：技能深入提升</h5><p>1、多线程和并发编程：学习使用Java并发包（如java.util.concurrent）处理多线程编程，了解线程池、锁机制和并发集合等。</p><p>2、性能优化：学习分析和调优Java应用程序的性能，了解内存管理、垃圾回收、性能监测和调优工具。</p><p>3、反射和字节码操作：学习使用Java的反射机制和字节码操作库，实现动态代理、代码生成和运行时修改类的功能。</p><p>4、函数式编程：学习Java 8及更高版本引入的函数式编程特性，如Lambda表达式和Stream API，提升代码简洁性和可读性。</p><p>5、设计模式：学习常见的设计模式，如单例模式、工厂模式、观察者模式等，了解如何应用设计模式解决常见的软件设计问题。</p><h5 id="阶段六：企业级项目实战"><a href="#阶段六：企业级项目实战" class="headerlink" title="阶段六：企业级项目实战"></a>阶段六：企业级项目实战</h5><p>1、需求分析和项目规划：与团队合作，了解项目需求，并制定项目计划和开发进度。</p><p>2、架构设计和技术选型：根据项目需求，设计系统架构，选择合适的技术栈和开发工具。</p><p>3、开发和测试：根据项目计划，进行系统开发和单元测试，确保代码的质量和功能的正确性。</p><p>4、集成和部署：将各个模块进行集成，进行系统测试，然后部署到生产环境。</p><p>5、运维和维护：监控系统的运行状态，及时处理故障和问题，并进行系统维护和升级。</p><h3 id="Spring速成"><a href="#Spring速成" class="headerlink" title="Spring速成"></a>Spring速成</h3><h5 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h5><ul><li>开源免费框架</li><li>轻量级、非入侵式</li><li>控制反转IOC 面向切片编程AOP</li><li>支持事物的处理和框架整合</li></ul><h5 id="ioc本质"><a href="#ioc本质" class="headerlink" title="ioc本质"></a>ioc本质</h5><p>控制反转是一种通过描述（XML或注解）并通过第三方去生产获取特定对象的方式，在spring中实现控制反转的是ioc容器，其实现方法是依赖注入（DI）。</p><h5 id="Springhello案例"><a href="#Springhello案例" class="headerlink" title="Springhello案例"></a>Springhello案例</h5><p>控制：谁来控制对象的创建，传统应用程序的对象是由程序本身，使用Spring后，由Spring来创建。</p><p>反转：程序本身不创建对象，而变成被动的接收对象。</p><p>依赖注入：利用set方法进行注入</p><p>IOC是一种编程思想，由主动的编程变成被动的接收。</p><p>可以通过newClsaaPathXmlApplicationContext去浏览底层代码。</p><p>到现在，实现不同操作，我们只用在xml配置文件中进行修改了。</p><h5 id="IOC创建对象方式"><a href="#IOC创建对象方式" class="headerlink" title="IOC创建对象方式"></a>IOC创建对象方式</h5><p>无参构造</p><p>有参构造</p><p>1、下标赋值  2、类型  3、参数名</p><p>总结：在配置文件加载时，容器中管理的对象就已经初始化了。</p><h5 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">alias 别名<br><br>配置<br>id:bean的唯一标识符，也就是相当于我们学的对象名<br>class:bean对象对应的全限定名：包名+类型<br>name:也是别名，可同时取多个<br><br>import<br>将多个配置文件合并成一个<br></code></pre></td></tr></table></figure><h5 id="DI注入"><a href="#DI注入" class="headerlink" title="DI注入"></a>DI注入</h5><p>构造器注入</p><p>set方式注入</p><ul><li>依赖：bean对象的创建依赖于容器</li><li>注入：bean对象的所有属性，由容器来注入</li></ul><p>拓展方式注入 </p><p>c命名和p命名空间注入</p><p>注意点：不能直接使用，需要导入xml约束</p><h5 id="Bean作用域"><a href="#Bean作用域" class="headerlink" title="Bean作用域"></a>Bean作用域</h5><p>singleton：默认机制</p><p>prototype：每次从容器中get时，都会产生一个新对象</p><p>其余的request、session、application只能在web开发中使用</p><h5 id="Bean的自动装配"><a href="#Bean的自动装配" class="headerlink" title="Bean的自动装配"></a>Bean的自动装配</h5><p>spring</p><p>1、在xml中显示配置</p><p>2、在java中显示配置</p><p>3、隐式的自动装配</p><p>byname:需要保证所有的bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致。</p><p>bytype:需要保证所有的bean的class唯一，并且这个bean需要和自动注入的属性的类型的值一致。</p><h5 id="使用注解实现自动装配"><a href="#使用注解实现自动装配" class="headerlink" title="使用注解实现自动装配"></a>使用注解实现自动装配</h5><p>使用须知：</p><p>1、导入约束：context约束</p><p>2、配置注解的支持：context:annotation-config</p><p>@Autowired</p><p>直接在属性上使用即可，也可以在set方式上使用</p><p>可以不用编写Set方法了，前提是这个自动装配的属性在IOC（Spring)容器中存在且符合名字Byname。</p><p>科普：@Nullable字段标记了这个注解，说明这个字段可以为null</p><p>如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解@Autowired实现时，可以使用@Qualifier(value&#x3D;”xxx”)去配置@Autowired，指定一个唯一的bean对象注入。</p><p>@Resource</p><p>和@Autowired一样都是用来自动装配的，都可以放在属性字段上</p><p>1、bean</p><p>2、属性如何注入</p><p>3、衍生的注解</p><p>@Component</p><ul><li>dao[@Repository]</li><li>service[@Service]</li><li>controller[Controller]</li></ul><p>4、自动装配</p><p>5、作用域</p><p>@Scope</p><p>6、小结</p><ul><li>xml更加万能，适用于任何场合，维护简单方便</li><li>注解 不是自己类使用不了，维护相对复杂</li></ul><p>一般：xml用来管理bean，注解只负责完成属性的注入</p><h5 id="使用Java的方式配置Spring"><a href="#使用Java的方式配置Spring" class="headerlink" title="使用Java的方式配置Spring"></a>使用Java的方式配置Spring</h5><p>Java </p><p>@Configuration 也会Spring容器托管，注册到容器中，因为他本来就是一个@Component。</p><p>@Component配合@ComponentScan使用，也可以单独使用@Bean进行方法注入</p><h5 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h5><p>SpringAOP的底层[SpringAOP和SpringMVC]</p><p>代理模式的分类：</p><ul><li><p>静态代理</p><p>角色分析：</p><ul><li><p>抽象角色：一般会使用接口或抽象类来解决</p></li><li><p>真实角色：被代理的角色</p></li><li><p>代理角色：代理真实角色，一般会做一些附属操作</p></li><li><p>客户：访问代理对象的人</p><p>在已有功能上增加一个日志输出：新建一个代理类，代理类中调用原方法，增加新功能。</p></li></ul></li><li><p>动态代理</p><ul><li>和静态代理角色一样</li><li>代理类是动态生成的，不是我们写好的</li><li>分为：基于接口的 和 基于类的动态代理<ul><li>基于接口：JDK动态代理</li><li>基于类：cglib</li><li>java字节码实现：javasist</li></ul></li></ul></li></ul><p>需要了解两个类：Proxy，InvocationHandler</p><h5 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h5><p>Aspect Oriented Programming面向切面编程</p><p>注意 动态代理代理的是接口</p><p>实现方式：</p><ul><li><p>方法一：使用Spring的API接口【主要是SpringAPI接口实现】</p></li><li><p>方法二：自定义类实现AOP【主要是切面定义】</p></li><li><p>方法三：使用注解@Aspect</p></li></ul><h5 id="整合Mybatis"><a href="#整合Mybatis" class="headerlink" title="整合Mybatis"></a>整合Mybatis</h5><p>步骤：</p><p>1、导入相关jar包</p><ul><li>junit</li><li>mybatis</li><li>mysql</li><li>spring相关的</li><li>aop</li><li>mybatis-spring</li></ul><p>2、编写配置文件</p><p>3、测试</p><h5 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h5><p>1、回顾事务</p><p>把一组业务当初一个业务来做：要么都成功，要么都失败。</p><p>事务ACID原则</p><ul><li>原子性</li><li>一致性</li><li>隔离性<ul><li>多个业务可能操作一个资源，防止数据损坏</li></ul></li><li>持久性<ul><li>事务一旦提交，无论发生什么</li></ul></li></ul><p>比如 先插入再删除，但删除代码有问题。执行时就不能插入成功，而应该作为整体，操作失败。</p><ul><li>声明式业务：AOP</li><li>编程式业务</li></ul><h4 id="Springboot速成"><a href="#Springboot速成" class="headerlink" title="Springboot速成"></a>Springboot速成</h4><ul><li>创建Maven项目</li><li>导入SpringBoot起步依赖</li><li>定义Controller</li><li>编写引导类：SpringBoot项目的入口</li><li>测试</li></ul><p>配置：properties&gt;yml&gt;yaml</p><p>yaml基本语法：</p><ul><li>大小写敏感</li><li>数据值前面必须有空格，作为分隔符</li><li>缩进表示层级关系</li><li>#表示注释</li></ul><p>数据格式</p><ul><li>对象（map）：键值对的集合</li><li>数组：一组按次序排列的值</li><li>纯量：单个的、不可分的值</li></ul><h5 id="读取配置内容"><a href="#读取配置内容" class="headerlink" title="读取配置内容"></a>读取配置内容</h5><ul><li>@Value 一个个注入</li><li>Environment</li><li>@ConfigurationProperties</li></ul><h5 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h5><p>动态配置切换</p><p>配置方式</p><ul><li>多profile文件方式<ul><li>application-dev.properties&#x2F;yml 开发环境</li><li>application-test.properties&#x2F;yml 测试环境</li><li>application-pro.properties&#x2F;yml 生产环境</li></ul></li><li>yml多文档方式<ul><li>使用—分割不同配置</li></ul></li></ul><p>激活方式</p><ul><li>配置文件：在配置文件中配置：spring.profile.active&#x3D;dev</li><li>虚拟机参数:在VM options指定：-Dspiring.profile.active&#x3D;dev</li><li>命令行参数：java-jar xxx.jar –spring.profiles.active&#x3D;dev</li></ul><p>内部配置加载顺序</p><ul><li>file:.&#x2F;config&#x2F;</li><li>file:.&#x2F;</li><li>classpath:&#x2F;config&#x2F;</li><li>classpath:&#x2F;</li></ul><p>外部配置加载顺序</p><h5 id="整合其他框架"><a href="#整合其他框架" class="headerlink" title="整合其他框架"></a>整合其他框架</h5><ul><li><p>Junit  单元测试框架</p></li><li><p>搭建SpringBoot工程</p><ul><li>引入start-test起步依赖</li></ul></li><li><p>编写测试类</p><ul><li><p>添加测试相关注解</p><ul><li>@RunWith(SpringRunner.class)</li></ul></li><li><p>@SpringBootTest(classes&#x3D;启动类.class)</p></li><li><p>编写测试方法</p></li></ul></li><li><p>Redis  <em>key-value 存储系统，是跨平台的非关系型数据库。</em></p><ul><li>搭建SpringBoot工程</li><li>引入redis起步依赖</li><li>配置redis相关属性</li><li>注入RedisTemplate模板</li><li>编写测试方法，测试</li></ul></li><li><p>mybaits  一个持久层框架，完成的是对数据库的访问和操作</p><ul><li>搭建SpringBoot工程 </li><li>引入mybaits起步依赖，添加mysql驱动</li><li>配置redis相关属性 </li><li>注入RedisTemplate模板 </li><li>编写测试方法，测试</li></ul></li></ul><h5 id="高级内容"><a href="#高级内容" class="headerlink" title="高级内容"></a>高级内容</h5><ul><li>原理分析</li><li>监控</li><li>项目部署</li></ul><h5 id="SpringBoot-Web开发"><a href="#SpringBoot-Web开发" class="headerlink" title="SpringBoot Web开发"></a>SpringBoot Web开发</h5><p>要解决的问题：</p><ul><li>导入静态资源</li><li>首页</li><li>jsp,模板引擎Thymelesf</li><li>装配扩展SpringMVC</li><li>增删改查</li><li>拦截器</li><li>国际化</li></ul><h5 id="shiro"><a href="#shiro" class="headerlink" title="shiro"></a>shiro</h5><p>安全权限框架</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端项目</title>
    <link href="/2023/11/24/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/"/>
    <url>/2023/11/24/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="考察目标"><a href="#考察目标" class="headerlink" title="考察目标"></a>考察目标</h1><ol><li>webpack的使用以及配置文件编写</li><li>react的使用</li><li>理解模块化，并且操作三方模块的引入</li><li>ES6语法基础</li><li>npm基础使用</li><li>Node.js的基础使用</li></ol><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><ul><li>前端：用react+typescript实现一个todo应用。并且将静态资源(html,js,css等)编译到node.js的静态资源目录中。端口：3000 </li><li>后端：使用node.js+javascript 将数据存储到服务端json文件中。端口3001</li><li>其它要求：两个项目的根目录下，要有READMD.md，记录自己的思路和遇到的问题。</li><li>两个项目的package.json，加注释（package.json.md）：说一下每一行的意思</li></ul><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><ul><li><ul><li><ul><li><p>client目录：前端react项目目录。</p></li><li><ul><li>client&#x2F;src 代码目录</li><li><code>npm run start</code> 开发模式，这个时候启动<a href="http://localhost:3000/index.html">http://localhost:3000/index.html</a> 用于开发，并且使用webpack-dev-server的proxy配置，将  &#x2F;api请求转发到3001。因此ajax请求是相对路径。</li><li><code>npm run build</code>: 编译代码，编译后的代码会存入build目录。（提示：使用koa-static配置静态资源目录为此build目录）</li></ul></li><li><p>server目录：服务端项目目录</p></li><li><ul><li><p>server&#x2F;代码目录</p></li><li><p>server&#x2F;public 静态资源，来自client目录build</p></li><li><p>接口：(create和update也可以合二为一)</p></li><li><ul><li>post &#x2F;api&#x2F;todo&#x2F;create 新建todo</li><li>post &#x2F;api&#x2F;todo&#x2F;update 修改</li><li>get &#x2F;api&#x2F;todo&#x2F;list 获取列表</li><li>post &#x2F;api&#x2F;todo&#x2F;delete 删除</li></ul></li></ul></li></ul></li></ul></li></ul><p>使用方法</p><ol><li>进入server目录，npm run start 启动3001端口，看是否正常</li><li>进入client目录执行npm run start，启动3000，看是否正常</li><li>停掉前端3000端口，进入client目录执行npm run build，看是否有报错.生成&#x2F;dist文件</li><li>打开 <a href="http://localhost:3001/index.html%EF%BC%8C%E4%BD%93%E9%AA%8C%E5%8A%9F%E8%83%BD%EF%BC%8C%E9%AA%8C%E8%AF%81%E4%BD%9C%E4%B8%9A%E5%AE%8C%E6%88%90%E5%BA%A6%E3%80%82">http://localhost:3001/index.html，体验功能，验证作业完成度。</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓学习</title>
    <link href="/2023/11/12/%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/11/12/%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="安卓速成"><a href="#安卓速成" class="headerlink" title="安卓速成"></a>安卓速成</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h4><p>Android其本质就是在标准的Linux系统上增加了Java虚拟机Dalvik，并在Dalvik虚拟机上搭建了一个JAVA的application framework，所有的应用程序都是基于JAVA的application framework之上。</p><h4 id="2-应用程序的架构设计"><a href="#2-应用程序的架构设计" class="headerlink" title="2 应用程序的架构设计"></a>2 应用程序的架构设计</h4><p>简化了组件的重用，隐藏在每个应用后面的是一系列的服务和系统, </p><p>其中包括：</p><ul><li><p>丰富而又可扩展的视图（Views），可以用来构建应用程序， 它包括列表（lists），网格（grids），文本框（text boxes），按钮（buttons）， 甚至可嵌入的web浏览器。</p></li><li><p>内容提供器（Content Providers）使得应用程序可以访问另一个应用程序的数据（如联系人数据库）， 或者共享它们自己的数据。</p></li><li><p>资源管理器（Resource Manager）提供非代码资源的访问，如本地字符串，图形，和布局文件（layout files）。</p></li><li><p>通知管理器（Notification Manager）使得应用程序可以在状态栏中显示自定义的提示信息。</p></li><li><p>活动管理器（Activity Manager）用来管理应用程序生命周期并提供常用的导航回退功能。</p></li></ul><h4 id="3-Android-执行程序"><a href="#3-Android-执行程序" class="headerlink" title="3 Android 执行程序"></a>3 <strong>Android</strong> <strong>执行程序</strong></h4><p>一个APK文件结构为：</p><ul><li><p>META-INF\ （注：Jar文件中常可以看到）；</p></li><li><p>res\ (注：存放资源文件的目录) ；</p></li><li><p>AndroidManifest.xml (注：程序全局配置文件) ；</p></li><li><p>classes.dex （注：Dalvik字节码）；</p></li><li><p>resources.arsc (注：编译后的二进制资源文件)。</p></li></ul><h4 id="4-Android开发的四大组件"><a href="#4-Android开发的四大组件" class="headerlink" title="4 Android开发的四大组件"></a>4 Android开发的四大组件</h4><ul><li>活动（Activity）： 用于表现功能。</li><li>服务（Service）： 后台运行服务，不提供界面呈现。</li><li>广播接收器（BroadcastReceiver）：用于接收广播。</li><li>内容提供商（Content Provider）：支持在多个应用中存储和读取数据，类似数据库。</li></ul><h4 id="5-Gradle"><a href="#5-Gradle" class="headerlink" title="5 Gradle"></a>5 <strong>Gradle</strong></h4><p>Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，抛弃了基于XML的各种繁琐配置。</p><p>gradle 作为编译工具，有很多的任务，比如 build、rebuild、clean 等。</p><h4 id="6-AndroidManifest-xml"><a href="#6-AndroidManifest-xml" class="headerlink" title="6 AndroidManifest.xml"></a>6 <strong>AndroidManifest.xml</strong></h4><p>AndroidManifest.xml 是每个android程序中必须的文件，它位于整个项目的根目录。AndroidManifest.xml是Android应用的入口文件，它描述了package中暴露的组件（activities, services, 等等），他们各自的实现类，各种能被处理的数据和启动位置。</p><h4 id="7-Android-模块文件"><a href="#7-Android-模块文件" class="headerlink" title="7 Android 模块文件"></a>7 <strong>Android 模块文件</strong></h4><ul><li><strong>AndroidManifest.xml：</strong> 包含应用程序的配置信息，如权限声明、组件声明等。</li><li><strong>build.gradle：</strong> 包含项目的构建配置，定义了项目的依赖关系、版本信息等。</li><li><strong>res&#x2F; 目录：</strong> 包含应用程序的资源文件，如布局文件、图标、字符串等。</li><li><strong>src&#x2F; 目录：</strong> 包含应用程序的源代码文件，按照主&#x2F;测试代码和各个模块进行组织。</li><li><strong>assets&#x2F; 目录：</strong> 包含应用程序需要在运行时使用的原始文件，如数据库文件、字体文件等。</li></ul><h4 id="8-Android-UI"><a href="#8-Android-UI" class="headerlink" title="8 Android UI"></a>8 <strong>Android UI</strong></h4><h5 id="五大布局"><a href="#五大布局" class="headerlink" title="五大布局"></a>五大布局</h5><ul><li>线性布局(LinearLayout)</li><li>框架布局(FrameLayout)</li><li>表格布局(TableLayout)</li><li>相对布局(RelativeLayout)</li><li>网格布局(GridLayout)</li></ul><h5 id="常用的组件"><a href="#常用的组件" class="headerlink" title="常用的组件"></a>常用的组件</h5><ul><li>TextView(文本框)</li><li>EditText(输入框)</li><li>Button(按钮)</li><li>ImageButton(图像按钮)</li><li>ImageView(图像视图)</li><li>RadioButton(单选按钮)&amp;Checkbox(复选框)</li><li>开关按钮ToggleButton和开关Switch</li><li>ProgressBar(进度条)</li><li>SeekBar(拖动条)</li><li>RatingBar(星级评分条)</li><li>ScrollView(滚动条)</li><li>Date &amp; Time组件等</li></ul><h5 id="Adapter-类"><a href="#Adapter-类" class="headerlink" title="Adapter 类"></a>Adapter 类</h5><p>Adapter是用来帮助填充数据的中间桥梁，简单点说就是：将各种数据以合适的形式显示到view上,提供给用户看。</p><p><a href="https://z1.ax1x.com/2023/11/14/piYP3hd.png"></a></p><p>关系图解析：</p><p>Model：通常可以理解为数据,负责执行程序的核心运算与判断逻辑,通过 view 获得用户输入的数据,然后根据从数据库查询相关的信息,最后进行运算和判断,再将得到的结果交给 view 来显示。<br>view:用户的操作接口,说白了就是 GUI,应该使用哪种接口组件,组件间的排列位置与顺序都需要设计。<br>Controller:控制器,作为model与view之间的枢纽,负责控制程序的执行流程以及对象之间的一个互动。</p><h6 id="ArrayAdapter使用示例"><a href="#ArrayAdapter使用示例" class="headerlink" title="ArrayAdapter使用示例"></a>ArrayAdapter使用示例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreat</span><span class="hljs-params">(Bundle savedInstanceState)</span>&#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        String[] strs = &#123;<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>&#125;;<br>        ArrayAdapter&lt;String&gt; adapter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayAdapter</span>&lt;String&gt;(<span class="hljs-built_in">this</span>,R.layout.simple_expandable_list_item_1,strs);<br>        <span class="hljs-type">ListView</span> <span class="hljs-variable">list_test</span> <span class="hljs-operator">=</span> (ListView) findViewByID(R.id.list_test);<br>        R.id.list_test.setAdapter;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="SimpleAdapter使用示例"><a href="#SimpleAdapter使用示例" class="headerlink" title="SimpleAdapter使用示例"></a>SimpleAdapter使用示例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String[] names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;B神&quot;</span>, <span class="hljs-string">&quot;基神&quot;</span>, <span class="hljs-string">&quot;曹神&quot;</span>&#125;;<br>    <span class="hljs-keyword">private</span> String[] says = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;无形被黑，最为致命&quot;</span>, <span class="hljs-string">&quot;大神好厉害~&quot;</span>, <span class="hljs-string">&quot;我将带头日狗~&quot;</span>&#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] imgIds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;R.mipmap.head_icon1, R.mipmap.head_icon2, R.mipmap.head_icon3&#125;;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br><br>        List&lt;Map&lt;String, Object&gt;&gt; listitem = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Map&lt;String, Object&gt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; names.length; i++) &#123;<br>            Map&lt;String, Object&gt; showitem = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();<br>            showitem.put(<span class="hljs-string">&quot;touxiang&quot;</span>, imgIds[i]);<br>            showitem.put(<span class="hljs-string">&quot;name&quot;</span>, names[i]);<br>            showitem.put(<span class="hljs-string">&quot;says&quot;</span>, says[i]);<br>            listitem.add(showitem);<br>        &#125;<br><br>        <span class="hljs-comment">//创建一个simpleAdapter</span><br>        <span class="hljs-type">SimpleAdapter</span> <span class="hljs-variable">myAdapter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleAdapter</span>(getApplicationContext(), listitem, R.layout.list_item, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;touxiang&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;says&quot;</span>&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;R.id.imgtou, R.id.name, R.id.says&#125;);<br>        <span class="hljs-type">ListView</span> <span class="hljs-variable">listView</span> <span class="hljs-operator">=</span> (ListView) findViewById(R.id.list_test);<br>        listView.setAdapter(myAdapter);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="ListView简单实用"><a href="#ListView简单实用" class="headerlink" title="ListView简单实用"></a>ListView简单实用</h6><h6 id="BaseAdapter优化"><a href="#BaseAdapter优化" class="headerlink" title="BaseAdapter优化"></a>BaseAdapter优化</h6><p>而这个Adapter则是中间的这个Controller的部分：</p><p>Model(数据) —&gt; Controller(以什么方式显示到)—&gt; View(用户界面) </p><ul><li>BaseAdapter：抽象类，实际开发中继承这个类并且重写相关方法，用得最多的一个Adapter！</li><li>ArrayAdapter：支持泛型操作，最简单的一个 Adapter，只能展现一行文字。</li><li>SimpleAdapter：同样具有良好扩展性的一个 Adapter，可以自定义多种效果！</li><li>SimpleCursorAdapter：用于显示简单文本类型的 listView，一般在数据库那里会用到，不过有点过时， 不推荐使用！</li></ul><p>其实一个BaseAdapter就够玩的了，至于其他的，实际开发中用得不多，后面用到再讲解。 </p><ul><li>ListView</li><li>GridView</li><li>Spinner</li><li>AutoCompleteTextView</li><li>ExpandableListView</li><li>ViewFlipper</li><li>ViewPager</li><li>DrawerLayout 等</li></ul><h6 id="常用的信息提示类的组件"><a href="#常用的信息提示类的组件" class="headerlink" title="常用的信息提示类的组件"></a>常用的信息提示类的组件</h6><ul><li>Toast</li><li>Notification</li><li>AlertDialog</li><li>PopupWindow</li></ul><h5 id="9事件处理机制"><a href="#9事件处理机制" class="headerlink" title="9事件处理机制"></a>9<strong>事件处理机制</strong></h5><p>事件处理机制就是我们和UI发生交互时，我们在背后添加一些小动作而已！</p><h6 id="基于监听的时间处理机制模型"><a href="#基于监听的时间处理机制模型" class="headerlink" title="基于监听的时间处理机制模型"></a><strong>基于监听的时间处理机制模型</strong></h6><ul><li><p><strong>直接用匿名内部类</strong></p></li><li><p><strong>使用内部类</strong> 使用优点:可以在该类中进行复用,可直接访问外部类的所有界面组件！</p></li><li><p>**使用外部类 **这种形式用的比较少！因为外部类不能直接访问</p><p>用户界面 类中的组件,要通过构造方法将组件传入使用;这样导致的结果就是代码不够简洁！</p></li><li><p><strong>直接使用Activity作为事件监听器</strong> 只需要让Activity类实现XxxListener事件监听接口,在Activity中定义重写对应的事件处理器方法</p></li><li><p><strong>直接绑定到标签</strong></p></li></ul><h6 id="基于回调的事件处理机制"><a href="#基于回调的事件处理机制" class="headerlink" title="基于回调的事件处理机制"></a><strong>基于回调的事件处理机制</strong></h6><h6 id="Handler消息传递机"><a href="#Handler消息传递机" class="headerlink" title="Handler消息传递机"></a><strong>Handler消息传递机</strong></h6><p>通过Handler来通知UI组件更新</p><h5 id="10四大组件"><a href="#10四大组件" class="headerlink" title="10四大组件"></a>10四大组件</h5><ul><li>活动（Activity）用于表现功能</li><li>服务（Service）在后台运行，不提供界面呈现</li><li>广播接收器（BroadcastReceiver）用于接收广播</li><li>内容提供商（Content Provider）支持在多个应用中存储和读取数据，类似数据库。</li></ul><h5 id="11Fragment"><a href="#11Fragment" class="headerlink" title="11Fragment"></a>11<strong>Fragment</strong></h5><p>Android运行在各种各样的设备中，有小屏幕的手机，超大屏的平板甚至电视。</p><ul><li>针对屏幕尺寸的差距，Fragment的出现就是为了解决这样的问题。你可以把Fragment当成Activity的一个界面的一个组成部分，甚至Activity的界面可以完全有不同的Fragment组成。</li><li>fragment拥有自己的生命周期和接收、处理用户的事件，这样就不必在Activity写一堆控件的事件处理的代码了。可以动态的添加、替换和移除某个Fragment。</li><li>一个页面可分为多个fragment，按钮点击动态添加fragment。</li><li>事务 实现返回栈addToBackStack()</li><li>Activty和Fragment的相互调用。</li><li>Fragment的状态和回调（异步 回调 多线程）</li><li>动态加载布局</li><li></li></ul><h5 id="12-Android-数据存储"><a href="#12-Android-数据存储" class="headerlink" title="12 Android 数据存储"></a>12 <strong>Android</strong> <strong>数据存储</strong></h5><p>SQLite</p><p>几个相关类：</p><ul><li>SQLiteOpenHelper 抽象类，继承该类，重写数据库创建及更新的方法，通过该类的对象获取数据库实例，或者关闭数据库。</li><li>SQLiteDatabase 数据库访问类，通过该类的对象对数据库做一些增删改查</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDBOpenHelper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SQLiteOpenHelper</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyDBOpenHelper</span><span class="hljs-params">(Context context, String name, CursorFactory factory,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> version)</span> &#123;<span class="hljs-built_in">super</span>(context, <span class="hljs-string">&quot;my.db&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">//数据库第一次创建时被调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(SQLiteDatabase db)</span> &#123;<br>        db.execSQL(<span class="hljs-string">&quot;CREATE TABLE person(personid INTEGER PRIMARY KEY AUTOINCREMENT,name VARCHAR(20))&quot;</span>);<br>        <br>    &#125;<br>    <span class="hljs-comment">//软件版本号发生改变时调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUpgrade</span><span class="hljs-params">(SQLiteDatabase db, <span class="hljs-type">int</span> oldVersion, <span class="hljs-type">int</span> newVersion)</span> &#123;<br>        db.execSQL(<span class="hljs-string">&quot;ALTER TABLE person ADD phone VARCHAR(12) NULL&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用使用Android提供的API操作SQLite</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">View</span>.OnClickListener &#123;<br><br>    <span class="hljs-keyword">private</span> Context mContext;<br>    <span class="hljs-keyword">private</span> Button btn_insert;<br>    <span class="hljs-keyword">private</span> Button btn_query;<br>    <span class="hljs-keyword">private</span> Button btn_update;<br>    <span class="hljs-keyword">private</span> Button btn_delete;<br>    <span class="hljs-keyword">private</span> SQLiteDatabase db;<br>    <span class="hljs-keyword">private</span> MyDBOpenHelper myDBHelper;<br>    <span class="hljs-keyword">private</span> StringBuilder sb;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        mContext = MainActivity.<span class="hljs-built_in">this</span>;<br>        myDBHelper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyDBOpenHelper</span>(mContext, <span class="hljs-string">&quot;my.db&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>);<br>        bindViews();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bindViews</span><span class="hljs-params">()</span> &#123;<br>        btn_insert = (Button) findViewById(R.id.btn_insert);<br>        btn_query = (Button) findViewById(R.id.btn_query);<br>        btn_update = (Button) findViewById(R.id.btn_update);<br>        btn_delete = (Button) findViewById(R.id.btn_delete);<br><br>        btn_query.setOnClickListener(<span class="hljs-built_in">this</span>);<br>        btn_insert.setOnClickListener(<span class="hljs-built_in">this</span>);<br>        btn_update.setOnClickListener(<span class="hljs-built_in">this</span>);<br>        btn_delete.setOnClickListener(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>        db = myDBHelper.getWritableDatabase();<br>        <span class="hljs-keyword">switch</span> (v.getId()) &#123;<br>            <span class="hljs-keyword">case</span> R.id.btn_insert:<br>                <span class="hljs-type">ContentValues</span> <span class="hljs-variable">values1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContentValues</span>();<br>                values1.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;呵呵~&quot;</span> + i);<br>                i++;<br>                <span class="hljs-comment">//参数依次是：表名，强行插入null值得数据列的列名，一行记录的数据</span><br>                db.insert(<span class="hljs-string">&quot;person&quot;</span>, <span class="hljs-literal">null</span>, values1);<br>                Toast.makeText(mContext, <span class="hljs-string">&quot;插入完毕~&quot;</span>, Toast.LENGTH_SHORT).show();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> R.id.btn_query:<br>                sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>                <span class="hljs-comment">//参数依次是:表名，列名，where约束条件，where中占位符提供具体的值，指定group by的列，进一步约束</span><br>                <span class="hljs-comment">//指定查询结果的排序方式</span><br>                <span class="hljs-type">Cursor</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> db.query(<span class="hljs-string">&quot;person&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>                <span class="hljs-keyword">if</span> (cursor.moveToFirst()) &#123;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">pid</span> <span class="hljs-operator">=</span> cursor.getInt(cursor.getColumnIndex(<span class="hljs-string">&quot;personid&quot;</span>));<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> cursor.getString(cursor.getColumnIndex(<span class="hljs-string">&quot;name&quot;</span>));<br>                        sb.append(<span class="hljs-string">&quot;id：&quot;</span> + pid + <span class="hljs-string">&quot;：&quot;</span> + name + <span class="hljs-string">&quot;\n&quot;</span>);<br>                    &#125; <span class="hljs-keyword">while</span> (cursor.moveToNext());<br>                &#125;<br>                cursor.close();<br>                Toast.makeText(mContext, sb.toString(), Toast.LENGTH_SHORT).show();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> R.id.btn_update:<br>                <span class="hljs-type">ContentValues</span> <span class="hljs-variable">values2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContentValues</span>();<br>                values2.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;嘻嘻~&quot;</span>);<br>                <span class="hljs-comment">//参数依次是表名，修改后的值，where条件，以及约束，如果不指定三四两个参数，会更改所有行</span><br>                db.update(<span class="hljs-string">&quot;person&quot;</span>, values2, <span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;呵呵~2&quot;</span>&#125;);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> R.id.btn_delete:<br>                <span class="hljs-comment">//参数依次是表名，以及where条件与约束</span><br>                db.delete(<span class="hljs-string">&quot;person&quot;</span>, <span class="hljs-string">&quot;personid = ?&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;3&quot;</span>&#125;);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/w3cnote/android-tutorial-sqlite-intro.html">相关代码</a></p><h5 id="13-Android-多媒体编程"><a href="#13-Android-多媒体编程" class="headerlink" title="13 Android 多媒体编程"></a>13 <strong>Android</strong> <strong>多媒体编程</strong></h5><h5 id="14-Android-绘图与动画"><a href="#14-Android-绘图与动画" class="headerlink" title="14 Android****绘图与动画"></a>14 <strong>Android****绘图与动画</strong></h5><h5 id="15-Android-网络编程"><a href="#15-Android-网络编程" class="headerlink" title="15 Android 网络编程"></a>15 <strong>Android</strong> <strong>网络编程</strong></h5><p>有 Http 协议，Json 解析类解析 Json，XML 解析的几种常用方式，HttpUrlConnection 和 HttpClient 的使用，文件的上传，</p><p>下载；WebService 的使用，WebView，Socket 通信的使用等。网络编程一般都需要增加权限</p><uses-permission android:name="android.permission.INTERNET" /><p>网络编程一般都使用第三方的组件，很少使用自带的，</p><h5 id="16-Android-消息处理机制"><a href="#16-Android-消息处理机制" class="headerlink" title="16 Android****消息处理机制"></a>16 <strong>Android****消息处理机制</strong></h5><h5 id="17-杂项开发"><a href="#17-杂项开发" class="headerlink" title="17 杂项开发"></a>17 <strong>杂项开发</strong></h5><p>不知道是不是因为之前导入别人的项目，改了很多设置后，今天运行安卓模拟器跑不起来，</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Cannot reach ADB <span class="hljs-keyword">server</span>, attempting <span class="hljs-keyword">to</span> reconnect.(moments ago)<br><br></code></pre></td></tr></table></figure><p>尝试更换模拟器，查看SDK与API，没有问题，没有解决。</p><p>最终解决：取消勾选 “Enable adb mDNS for wireless debugging”</p><p>具体位置File-Settings-Build, Extension, Deployment-Debugger或者直接搜 adb</p><p>Fragment开发，平板模拟器竖着的。</p><p>解决：平板模拟器内部的屏幕设置问题</p><p><a href="https://blog.csdn.net/Sophorae/article/details/105322700">https://blog.csdn.net/Sophorae/article/details/105322700</a></p><p>kotlin-android-extensions插件也被废弃了</p><p>升级了Android Studio 4.1之后，发现新建项目的时候Android Studio已经不会自动帮我们引入kotlin-android-extensions插件了，需要自己手动去添加才能使用，是不是Google不再推荐使用这个插件了？</p><p>《第一行代码 第3版》的另外一篇DLC：<a href="https://blog.csdn.net/guolin_blog/article/details/113089706">https://blog.csdn.net/guolin_blog/article/details/113089706</a></p><h3 id="kotlin"><a href="#kotlin" class="headerlink" title="kotlin"></a>kotlin</h3><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>关键字只有val和var</p><p>不加分号</p><p>变量延迟赋值时，需要显示申明变量类型</p><p> if when 循环语句for in</p><p>面向对象编程</p><h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5><p>在后台执行长时间运行操作的组件 不允许子线程进行UI操作，但有时我们必须在子线程进行一些耗时操作，然后根据任务的执行结果更新UI控件 异步消息处理机制</p><ul><li>解析异步消息处理机制 Message Handle MessageQueue Looper</li><li>使用AsyncTask</li><li>onBind 唯一的抽象方法</li><li>启动和停止主要是通过Intent实现的</li><li>Activity和Service进行通信 Binder</li><li>前台Service</li><li>多线程 Service的每个方法里面里开启一个子线程  异步的会自动停止的IntentService</li></ul><h5 id="Jetpack"><a href="#Jetpack" class="headerlink" title="Jetpack"></a>Jetpack</h5><ul><li>开发模式 MVVM ViewModel ViewModelProvider Factory</li><li>多个库组成的套件 基础 架构 行为 界面</li><li>Lifecycle 感知生命周期，响应的时间问题</li><li>ViewModel 管理页面数据</li><li>LiveData 数据持有类 map switchMap</li><li>ViewBinding 视图绑定</li><li>DataBinding  数据绑定</li><li>Room框架 数据库</li><li>Hilt</li><li>协程  CoroutineScope async await 协程作用域 withContent挂起函数 在Retrofit和架构组件里面使用协程 Flow冷流 StateFlow SharedFlow</li><li>Paging</li><li>Compose</li></ul><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>都是问一些底层的运行逻辑，java相关的。</p><p>很多专业术语都是英文首字母简称。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/11/12/hello-world/"/>
    <url>/2023/11/12/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
