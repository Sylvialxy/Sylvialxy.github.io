<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>算法学习</title>
    <link href="/2025/02/16/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/02/16/%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="算法基础"><a href="#算法基础" class="headerlink" title="算法基础"></a>算法基础</h2><p>刷题计划：</p><p>1、刷完acwing</p><p>2、刷完leetcode</p><h3 id="acwing基础算法"><a href="#acwing基础算法" class="headerlink" title="acwing基础算法"></a>acwing基础算法</h3><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>我会联想动态的图来记忆。可以在网上看一些图解来记忆。</p><p>选择 插入 （有点类似打扑克抓牌，慢）<br>冒泡 堆<br>归并（分治、递归）  快速（有点像班级排身高，分治、选基准元素）</p><ol><li><p>冒泡排序（Bubble Sort）：</p><p><strong>相邻两个数两两相比，重复n次。</strong></p><ul><li>稳定性：稳定</li></ul></li></ol><ul><li>时间复杂度：平均情况和最坏情况均为O(n^2)，因为每一个数都要与其他数比较一次。<ul><li>空间复杂度：O(1)</li><li>主要特点：相邻元素两两比较，若逆序则交换。</li></ul></li></ul><ol start="2"><li><p>选择排序（Selection Sort）：<br><strong>第一个数和后面所有的数比较，找出最小的，放在第一个，重复n轮。</strong></p><ul><li>稳定性：不稳定</li><li>时间复杂度：平均情况和最坏情况均为O(n^2)，因为每一个数都要与其他数比较一次。</li><li>空间复杂度：O(1)</li><li>主要特点：每次选择未排序部分的最小元素，放到已排序部分的末尾。</li></ul></li><li><p><strong>插入排序（Insertion Sort）</strong>：</p><p><strong>类似打牌时抓牌排列。从第一个数开始，给他找位置，依次重复。</strong></p><ul><li>稳定性：稳定</li><li>时间复杂度：平均情况和最坏情况均为O(n^2)，，因为每一个数都要与其他数比较一次。</li><li>空间复杂度：O(1)</li><li>主要特点：将元素逐个插入到已排序的部分，构建有序序列。</li></ul></li><li><p><strong>快速排序（Quick Sort）</strong>：</p><p><strong>分治，基数。选一个数做基数，小的左边，大的右边，一趟结束，将基数放到中间。以基数位置来分隔，左右两边重复。</strong></p><ul><li>稳定性：不稳定</li><li>时间复杂度：平均情况为O(nlogn)，最坏情况为O(n^2)</li><li>空间复杂度：平均情况为O(logn)，最坏情况为O(n)</li><li>主要特点：采用分治法，通过选取基准元素将数组分为两部分，然后递归地对子数组进行排序。</li></ul></li><li><p><strong>归并排序（Merge Sort）</strong>：</p><p><strong>对半分到最小，在向上归并</strong></p><ul><li>稳定性：稳定</li><li>时间复杂度：平均情况和最坏情况均为O(nlogn)</li><li>空间复杂度：O(n)</li><li>主要特点：采用分治法，将数组分成两个子数组，分别排序后再合并。</li></ul></li><li><p><strong>堆排序（Heap Sort）</strong>：</p><p>构造最大堆或者最小堆,根元素就是最大值&#x2F;最小值,取下,重复,形成序列.</p><ul><li>稳定性：不稳定</li><li>时间复杂度：平均情况和最坏情况均为O(nlogn)</li><li>空间复杂度：O(1)</li><li>主要特点：利用堆数据结构，将数组构建成最大堆（最小堆），然后依次取出堆顶元素。</li></ul></li></ol><blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++">    <span class="hljs-comment">/*快速排序算法模板 —— 模板题 AcWing 785. 快速排序</span><br><span class="hljs-comment">分治</span><br><span class="hljs-comment">1、确定分界点 左 中 右</span><br><span class="hljs-comment">2、调整区间</span><br><span class="hljs-comment">3、递归处理左右两段</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> i = l - <span class="hljs-number">1</span>, j = r + <span class="hljs-number">1</span>, x = q[l + r &gt;&gt; <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">while</span> (i &lt; j)<br>    &#123;<br>        <span class="hljs-keyword">do</span> i ++ ; <span class="hljs-keyword">while</span> (q[i] &lt; x);<br>        <span class="hljs-keyword">do</span> j -- ; <span class="hljs-keyword">while</span> (q[j] &gt; x);<br>        <span class="hljs-keyword">if</span> (i &lt; j) <span class="hljs-built_in">swap</span>(q[i], q[j]);<br>    &#125;<br>    <span class="hljs-built_in">quick_sort</span>(q, l, j), <span class="hljs-built_in">quick_sort</span>(q, j + <span class="hljs-number">1</span>, r);<br>&#125;<br><br>归并排序算法模板 —— 模板题 AcWing <span class="hljs-number">787.</span> 归并排序<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(<span class="hljs-type">int</span> q[], <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (l &gt;= r) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-built_in">merge_sort</span>(q, l, mid);<br>    <span class="hljs-built_in">merge_sort</span>(q, mid + <span class="hljs-number">1</span>, r);<br><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">0</span>, i = l, j = mid + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r)<br>        <span class="hljs-keyword">if</span> (q[i] &lt;= q[j]) tmp[k ++ ] = q[i ++ ];<br>        <span class="hljs-keyword">else</span> tmp[k ++ ] = q[j ++ ];<br><br>    <span class="hljs-keyword">while</span> (i &lt;= mid) tmp[k ++ ] = q[i ++ ];<br>    <span class="hljs-keyword">while</span> (j &lt;= r) tmp[k ++ ] = q[j ++ ];<br><br>    <span class="hljs-keyword">for</span> (i = l, j = <span class="hljs-number">0</span>; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h4 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h4><p><strong>左边红色性质</strong>，右边绿色性质。</p><ul><li><p>模板一：<br>目的：找到绿色边界<br>mid&#x3D; l+r&gt;&gt;1<br>check(mid)检测mid是否再右半绿色区域<br>为ture,则绿色边界的范围由[l,r]更新为[l,mid],一一对应，<strong>r&#x3D;mid</strong>,r更新为mid<br>为false,则绿色边界的范围[l,r]更新为[mid+1,r],一一对应，<strong>l&#x3D;mid+1</strong>,l更新为mid+1</p></li><li><p>模板二：<br>目的：<strong>找到红色边界</strong>，即左半红色区域的右边界<br>mid&#x3D;l+r**+1** &gt;&gt;1<br>check(mid)检测mid是否在左半红色区域<br>为ture，则红色<strong>边界</strong>的范围由[l,r]更新为[mid,r],一一对应，<strong>l&#x3D;mid</strong>,l更新为mid<br>为false,则红色边界的范围由[l,r]更新为[l,mid],一一对应，<strong>r&#x3D;mid-1</strong>,更新为mid-1</p></li></ul><p>为什么模板二要+1？<br>假设当l&#x3D;r-1,由于在c++中向下（小）取整，mid&#x3D;(l+l+1)&#x2F;2&#x3D;l,假设check(mid)&#x3D;true,那么红色边界的范围更新后仍然为[l,r]，继续循环则陷入死循环，因此需要+1</p><p>简记：（l更新为mid时要+1），<strong>答案要向左靠就别加1</strong>，答案要向右靠就加1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs C++">整数二分算法模板 —— 模板题 AcWing <span class="hljs-number">789.</span> 数的范围<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-comment">//向右靠 区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_2</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) l = mid;<br>        <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-comment">// 向左靠 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">bsearch_1</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;    <span class="hljs-comment">// check()判断mid是否满足性质</span><br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">100010</span>;<br><span class="hljs-type">int</span> n, m;<br><span class="hljs-type">int</span> q[N];<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++ ) <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;q[i]);<br><br>    <span class="hljs-keyword">while</span> (m -- )<br>    &#123;<br>        <span class="hljs-type">int</span> x;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br><br>        <span class="hljs-comment">//模板，找左端点，右边所有的数满足性质，往右找</span><br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (l &lt; r)<br>        &#123;<br>            <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (q[mid] &gt;= x) r = mid;<br>            <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (q[l] != x) cout &lt;&lt; <span class="hljs-string">&quot;-1 -1&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            cout &lt;&lt; l &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br><br>            <span class="hljs-comment">//模板，找右端点，左边所有的数满足性质，往左找</span><br>            <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = n - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (l &lt; r)<br>            &#123;<br>                <span class="hljs-type">int</span> mid = l + r + <span class="hljs-number">1</span> &gt;&gt; <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (q[mid] &lt;= x) l = mid;<br>                <span class="hljs-keyword">else</span> r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br><br>            cout &lt;&lt; l &lt;&lt; endl;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br><br>浮点数二分算法模板 —— 模板题 AcWing <span class="hljs-number">790.</span> 数的三次方根<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(<span class="hljs-type">double</span> x)</span> </span>&#123;<span class="hljs-comment">/* ... */</span>&#125; <span class="hljs-comment">// 检查x是否满足某种性质</span><br><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">bsearch_3</span><span class="hljs-params">(<span class="hljs-type">double</span> l, <span class="hljs-type">double</span> r)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">double</span> eps = <span class="hljs-number">1e-6</span>;   <span class="hljs-comment">// eps 表示精度，取决于题目对精度的要求</span><br>    <span class="hljs-keyword">while</span> (r - l &gt; eps)<br>    &#123;<br>        <span class="hljs-type">double</span> mid = (l + r) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="高精度"><a href="#高精度" class="headerlink" title="高精度"></a>高精度</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs C++">高精度加法 —— 模板题 AcWing <span class="hljs-number">791.</span> 高精度加法<br><span class="hljs-comment">// C = A + B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">add</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (A.<span class="hljs-built_in">size</span>() &lt; B.<span class="hljs-built_in">size</span>()) <span class="hljs-keyword">return</span> <span class="hljs-built_in">add</span>(B, A);<br><br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t += A[i];<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t += B[i];<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (t) C.<span class="hljs-built_in">push_back</span>(t);<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br>高精度减法 —— 模板题 AcWing <span class="hljs-number">792.</span> 高精度减法<br><span class="hljs-comment">// C = A - B, 满足A &gt;= B, A &gt;= 0, B &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sub</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, vector&lt;<span class="hljs-type">int</span>&gt; &amp;B)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, t = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>(); i ++ )<br>    &#123;<br>        t = A[i] - t;<br>        <span class="hljs-keyword">if</span> (i &lt; B.<span class="hljs-built_in">size</span>()) t -= B[i];<br>        C.<span class="hljs-built_in">push_back</span>((t + <span class="hljs-number">10</span>) % <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">if</span> (t &lt; <span class="hljs-number">0</span>) t = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> t = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br>高精度乘低精度 —— 模板题 AcWing <span class="hljs-number">793.</span> 高精度乘法<br><span class="hljs-comment">// C = A * b, A &gt;= 0, b &gt;= 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">mul</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br><br>    <span class="hljs-type">int</span> t = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; A.<span class="hljs-built_in">size</span>() || t; i ++ )<br>    &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; A.<span class="hljs-built_in">size</span>()) t += A[i] * b;<br>        C.<span class="hljs-built_in">push_back</span>(t % <span class="hljs-number">10</span>);<br>        t /= <span class="hljs-number">10</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br><br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br>高精度除以低精度 —— 模板题 AcWing <span class="hljs-number">794.</span> 高精度除法<br><span class="hljs-comment">// A / b = C ... r, A &gt;= 0, b &gt; 0</span><br><span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">div</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt; &amp;A, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span> &amp;r)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; C;<br>    r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = A.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i -- )<br>    &#123;<br>        r = r * <span class="hljs-number">10</span> + A[i];<br>        C.<span class="hljs-built_in">push_back</span>(r / b);<br>        r %= b;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(C.<span class="hljs-built_in">begin</span>(), C.<span class="hljs-built_in">end</span>());<br>    <span class="hljs-keyword">while</span> (C.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; C.<span class="hljs-built_in">back</span>() == <span class="hljs-number">0</span>) C.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">return</span> C;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="前缀和与差分"><a href="#前缀和与差分" class="headerlink" title="前缀和与差分"></a>前缀和与差分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++">一维前缀和 —— 模板题 AcWing <span class="hljs-number">795.</span> 前缀和<br>S[i] = a[<span class="hljs-number">1</span>] + a[<span class="hljs-number">2</span>] + ... a[i]<br>a[l] + ... + a[r] = S[r] - S[l - <span class="hljs-number">1</span>]<br>二维前缀和 —— 模板题 AcWing <span class="hljs-number">796.</span> 子矩阵的和<br>S[i, j] = 第i行j列格子左上部分所有元素的和<br>以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：<br>S[x2, y2] - S[x1 - <span class="hljs-number">1</span>, y2] - S[x2, y1 - <span class="hljs-number">1</span>] + S[x1 - <span class="hljs-number">1</span>, y1 - <span class="hljs-number">1</span>]<br>一维差分 —— 模板题 AcWing <span class="hljs-number">797.</span> 差分<br>给区间[l, r]中的每个数加上c：B[l] += c, B[r + <span class="hljs-number">1</span>] -= c<br>二维差分 —— 模板题 AcWing <span class="hljs-number">798.</span> 差分矩阵<br>给以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵中的所有元素加上c：<br>S[x1, y1] += c, S[x2 + <span class="hljs-number">1</span>, y1] -= c, S[x1, y2 + <span class="hljs-number">1</span>] -= c, S[x2 + <span class="hljs-number">1</span>, y2 + <span class="hljs-number">1</span>] += c<br></code></pre></td></tr></table></figure><h4 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h4><h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++">位运算 —— 模板题 AcWing <span class="hljs-number">801.</span> 二进制中<span class="hljs-number">1</span>的个数<br>求n的第k位数字: n &gt;&gt; k &amp; <span class="hljs-number">1</span><br>返回n的最后一位<span class="hljs-number">1</span>：<span class="hljs-built_in">lowbit</span>(n) = n &amp; -n<br>双指针算法 —— 模板题 AcWIng <span class="hljs-number">799.</span> 最长连续不重复子序列, AcWing <span class="hljs-number">800.</span> 数组元素的目标和<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; i &lt; n; i ++ )<br>&#123;<br>    <span class="hljs-keyword">while</span> (j &lt; i &amp;&amp; <span class="hljs-built_in">check</span>(i, j)) j ++ ;<br><br>    <span class="hljs-comment">// 具体问题的逻辑</span><br>&#125;<br>常见问题分类：<br>    (<span class="hljs-number">1</span>) 对于一个序列，用两个指针维护一段区间<br>    (<span class="hljs-number">2</span>) 对于两个序列，维护某种次序，比如归并排序中合并两个有序序列的操作<br></code></pre></td></tr></table></figure><h4 id="离散化"><a href="#离散化" class="headerlink" title="离散化"></a>离散化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++">离散化 —— 模板题 AcWing <span class="hljs-number">802.</span> 区间和<br>vector&lt;<span class="hljs-type">int</span>&gt; alls; <span class="hljs-comment">// 存储所有待离散化的值</span><br><span class="hljs-built_in">sort</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()); <span class="hljs-comment">// 将所有值排序</span><br>alls.<span class="hljs-built_in">erase</span>(<span class="hljs-built_in">unique</span>(alls.<span class="hljs-built_in">begin</span>(), alls.<span class="hljs-built_in">end</span>()), alls.<span class="hljs-built_in">end</span>());   <span class="hljs-comment">// 去掉重复元素</span><br><br><span class="hljs-comment">// 二分求出x对应的离散化的值</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> <span class="hljs-comment">// 找到第一个大于等于x的位置</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, r = alls.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt; r)<br>    &#123;<br>        <span class="hljs-type">int</span> mid = l + r &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (alls[mid] &gt;= x) r = mid;<br>        <span class="hljs-keyword">else</span> l = mid + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span>; <span class="hljs-comment">// 映射到1, 2, ...n</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="区间合并"><a href="#区间合并" class="headerlink" title="区间合并"></a>区间合并</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++">区间合并 —— 模板题 AcWing <span class="hljs-number">803.</span> 区间合并<br><span class="hljs-comment">// 将所有存在交集的区间合并</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(vector&lt;PII&gt; &amp;segs)</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;PII&gt; res;<br><br>    <span class="hljs-built_in">sort</span>(segs.<span class="hljs-built_in">begin</span>(), segs.<span class="hljs-built_in">end</span>());<br><br>    <span class="hljs-type">int</span> st = <span class="hljs-number">-2e9</span>, ed = <span class="hljs-number">-2e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> seg : segs)<br>        <span class="hljs-keyword">if</span> (ed &lt; seg.first)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br>            st = seg.first, ed = seg.second;<br>        &#125;<br>        <span class="hljs-keyword">else</span> ed = <span class="hljs-built_in">max</span>(ed, seg.second);<br><br>    <span class="hljs-keyword">if</span> (st != <span class="hljs-number">-2e9</span>) res.<span class="hljs-built_in">push_back</span>(&#123;st, ed&#125;);<br><br>    segs = res;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>链表与邻接表：树与图的存储<br>栈与队列：单调队列、单调栈<br>kmp<br>Trie<br>并查集<br>堆<br>Hash表</p><h3 id="搜索与图论"><a href="#搜索与图论" class="headerlink" title="搜索与图论"></a>搜索与图论</h3><p>DFS与BFS<br>树与图的遍历：拓扑排序<br>最短路<br>最小生成树<br>二分图：染色法、匈牙利算法</p><h3 id="数学知识"><a href="#数学知识" class="headerlink" title="数学知识"></a>数学知识</h3><p>质数<br>约数<br>欧拉函数<br>快速幂<br>扩展欧几里得算法<br>中国剩余定理<br>高斯消元<br>组合计数<br>容斥原理<br>简单博弈论</p><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><p>背包问题<br>线性DP<br>区间DP<br>计数类DP<br>数位统计DP<br>状态压缩DP<br>树形DP<br>记忆化搜索</p><h3 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h3><h3 id="时空复杂度分析"><a href="#时空复杂度分析" class="headerlink" title="时空复杂度分析"></a>时空复杂度分析</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2025/01/15/hello-world/"/>
    <url>/2025/01/15/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>经济学基础</title>
    <link href="/2024/10/16/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%9F%BA%E7%A1%80/"/>
    <url>/2024/10/16/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p>c</p><p>长期收益只能有6.6%  </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>研究生规划</title>
    <link href="/2024/10/06/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%A7%84%E5%88%92/"/>
    <url>/2024/10/06/%E7%A0%94%E7%A9%B6%E7%94%9F%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>z</p><p>研二暑期实习</p><p>专利毕业</p><p>大论文 小论文</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>大前端学习</title>
    <link href="/2024/09/21/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/09/21/%E5%A4%A7%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><p>最受欢迎的是大前端路线，即，Android、iOS、鸿蒙、H5、小程序，反正都是做页面渲染。</p><h4 id="Web前端"><a href="#Web前端" class="headerlink" title="Web前端"></a>Web前端</h4><h5 id="整体目标"><a href="#整体目标" class="headerlink" title="整体目标"></a>整体目标</h5><ol><li>了解大前端的概念以及前端的能力边界</li><li>了解掌握 Web 前端基础开发环境的使用</li><li>基本掌握前端工程搭建能力</li><li>基本掌握 React 框架开发技巧</li><li>熟悉Vue框架的开发技巧</li><li>基本掌握 Node.JS 开发技巧</li><li>成为具有全栈思维的程序员及架构师</li></ol><p>前端经典面试题：输入URL后发生了什么？</p><p><a href="https://imgse.com/i/piY58nP"><img src="https://z1.ax1x.com/2023/11/15/piY58nP.md.png" alt="piY58nP.md.png" style="zoom:50%;" /></a></p><p>浏览器渲染过程：DOM树构建</p><h5 id="HTML、CS、JavaScript"><a href="#HTML、CS、JavaScript" class="headerlink" title="HTML、CS、JavaScript"></a>HTML、CS、JavaScript</h5><h5 id="DOM基本操作"><a href="#DOM基本操作" class="headerlink" title="DOM基本操作"></a>DOM基本操作</h5><p>DOM（Document Object Model — 文档对象模型）是用来呈现以及与任意 HTML 或 XML文档交互的API。</p><p>我们可以通过js调用浏览器提供的API，进行DOM的创建、查询、删除、替换等操作，还可以监听DOM的操作（如鼠标点击、键盘输入）事件，让我们对用户的操作做出响应，如今借助于React之类的框架，我们在实际开发中已经很少需要直接操作DOM了，但是仍然有必要了解一下DOM的基本设计和常用操作。</p><ul><li><p>增查删改</p></li><li><p>DOM节点属性与方法</p></li><li><p>DOM生命周期</p></li></ul><h5 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h5><p>常用事件：<br>• 文档事件，加载，卸载等。<br>• 鼠标，键盘，移动端触控，表单输入等用户交互事件<br>• 网络处理事件<br>• 其他：媒体事件，全屏等</p><p>事件绑定的两种方法：</p><ul><li>方法1：onXXXEventName 作为DOM的属性，去掉属性相当于解绑事件</li><li>方法2：addEventListener&#x2F;removeEventLister方法。一般建议用此方法。</li></ul><h5 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h5><p>事件委托的意义：<br>1.性能提升<br>2.子节点发生变化（增加或删除），不影响代码运行</p><h5 id="BOM与浏览器API"><a href="#BOM与浏览器API" class="headerlink" title="BOM与浏览器API"></a>BOM与浏览器API</h5><p>BOM(browser object model–浏览器对象模型)，属于约定俗称，在各自浏览器中都有各自的实现，并没有统一的标准。但大多数的接口都是通用的。BOM提供了独立于内容而与浏览器窗口进行交互的对象，由于BOM主要用于管理窗口与窗口之间的通讯，因此其核心对象是window。BOM由一系列相关的对象构成，并且每个对象都提供了很多方法与属性，常见的对象有：document、location、navigator、screen、history。</p><h5 id="CSS中万物皆盒"><a href="#CSS中万物皆盒" class="headerlink" title="CSS中万物皆盒"></a>CSS中万物皆盒</h5><h6 id="Flex-布局-Grid-布局"><a href="#Flex-布局-Grid-布局" class="headerlink" title="Flex 布局 Grid 布局"></a>Flex 布局 Grid 布局</h6><h6 id="响应式设计"><a href="#响应式设计" class="headerlink" title="响应式设计"></a>响应式设计</h6><p>•使用Flex、Grid布局<br>• 媒体查询<br>• 响应式图片<br>• rem</p><h5 id="Javascript-基础语法"><a href="#Javascript-基础语法" class="headerlink" title="Javascript 基础语法"></a>Javascript 基础语法</h5><ol><li><p>变量 有三个关键字可以声明变量：var、let 和 const。</p></li><li><p>程序控制</p></li><li><p>函数 高阶函数 匿名函数 闭包</p></li><li><p>面向对象与原型链</p></li><li><p>对象代理 Proxy</p><p>Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。<br>• 比defineProperty更强大。<br>• ES6新语法<br>• vue3双向绑定基于Proxy实现</p></li><li><p>异步编程</p><p>异步通常用于处理一些耗时的操作，比如说IO、网络请求、耗时计算等，在早期处理异步时，我们通常会使用事件和回调来处理。常见的异步有，事件监听、setTimeout、setInterval等</p></li></ol><p>Promise 就是用来解决异步回调问题而出现的解决方案。它让你能够把异步操作最终的成功返回值或者失败原因和相应的处理程序关联起来。</p><p>一个 Promise 必然处于以下几种状态之一：<br>• 待定（pending）: 初始状态，既没有被兑现，也没有被拒绝。<br>• 已兑现（fulfilled）: 意味着操作成功完成。<br>• 已拒绝（rejected）: 意味着操作失败。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//用 Promise 和 setTimeout 来封装一个异步请求面积的方法</span><br>fuction <span class="hljs-title function_">asyncArea</span>(<span class="hljs-params">length</span>)&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br><span class="hljs-title function_">setTimeout</span>(<span class="hljs-params">()=&gt;</span>)&#123;<br>           <span class="hljs-keyword">if</span> (length&gt;<span class="hljs-number">0</span>) <span class="hljs-title function_">resolve</span>(length*length)<br>           <span class="hljs-keyword">else</span> <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`invalid length: <span class="hljs-subst">$&#123;length&#125;</span>`</span>))<br>&#125;,<span class="hljs-number">500</span>)<br>&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>Promise 通过 then 来进行异步请求虽然改善了回调的问题，但还是不够优雅，好在现在我们可以<br>通过 async&#x2F;await 语法，使用串行的语法进行异步调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> fuction <span class="hljs-title function_">test_1</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br>    <span class="hljs-keyword">let</span> result_1=<span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncArea</span>(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">let</span> result_2=<span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncArea</span>(result_1+<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">let</span> result_3=<span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncArea</span>(result_2+<span class="hljs-number">1</span>)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;test_1&#x27;</span>,result_3)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`cost <span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()-start&#125;</span>ms`</span>)<br>&#125;<br><span class="hljs-title function_">test_1</span>()<br><br><span class="hljs-keyword">async</span> fuction <span class="hljs-title function_">test_2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> start = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>()<br>    <span class="hljs-keyword">let</span> result=<span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">all</span>([<br>        <span class="hljs-title function_">asyncArea</span>(<span class="hljs-number">1</span>),<br>        <span class="hljs-title function_">asyncArea</span>(<span class="hljs-number">2</span>),<br>        <span class="hljs-title function_">asyncArea</span>(<span class="hljs-number">3</span>),<br>        <span class="hljs-title function_">asyncArea</span>(<span class="hljs-number">4</span>),<br>        <span class="hljs-title function_">asyncArea</span>(<span class="hljs-number">5</span>)<br>    ])<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;test_2&#x27;</span>,result)<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`cost <span class="hljs-subst">$&#123;<span class="hljs-built_in">Date</span>.now()-start&#125;</span>ms`</span>)<br>&#125;<br><span class="hljs-title function_">test_2</span>()<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> fuction <span class="hljs-title function_">run</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">asyncArea</span>(-<span class="hljs-number">1</span>)<br>        cnsole.<span class="hljs-title function_">log</span>(result)<br>    &#125;<span class="hljs-keyword">catch</span>(error)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">message</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-title function_">asyncArea</span>(-<span class="hljs-number">1</span>)<br>    &#125;<span class="hljs-keyword">catch</span>(error)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error.<span class="hljs-property">message</span>)<br>    &#125;<br>    <br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-title function_">asyncArea</span>(-<span class="hljs-number">1</span>).<span class="hljs-title function_">catch</span>(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span>&#123;<br>            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>,error.<span class="hljs-property">message</span>)<br>        &#125;) <br>    &#125;<span class="hljs-keyword">catch</span>(error)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span>,error.<span class="hljs-property">message</span>)<br>    &#125;<br>&#125;<br><span class="hljs-title function_">run</span>()<br></code></pre></td></tr></table></figure><p>常见对象及其API</p><ol><li>String</li><li>Array</li><li>Object</li><li>Set</li><li>Map</li><li>JSON</li><li>Math</li><li>XMLHttpRequest</li><li>Storage</li><li>Error</li></ol><h5 id="前端工程化与Typescript"><a href="#前端工程化与Typescript" class="headerlink" title="前端工程化与Typescript"></a>前端工程化与Typescript</h5><p>在不使用模块系统的情况下，项目化变得难以维护。</p><ul><li>什么是前端工程化？</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">模块化、组件化、打包方案、自动化流程<br></code></pre></td></tr></table></figure><p>最终目标:</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">高性能、稳定性<span class="hljs-comment">(reliability)</span>、可用性<span class="hljs-comment">(usability)</span>、可维护性<span class="hljs-comment">(maintainability)</span>、可访问性<span class="hljs-comment">(accesibility)</span><br></code></pre></td></tr></table></figure><ul><li><p>JS模块化</p><ul><li><p>CommonJs</p><p>使用module.exports导出、require导入</p></li><li><p>EsModules</p><p>可以使用export和export default,s使用import语法导入，单个导入必须使用花括号。</p></li></ul></li><li><p>Node.js与模块化</p></li></ul><p>作为一个异步事件驱动的JavaScript运行时，Node.js被设计用来构建可扩展的网络应用。在下面的“Hello World”示例中，可以并发处理许多连接，每一个连接都会触发一个回调，而当没有可做的事情时，Node.js就会进入休眠状态。</p><p>-<br>  包管理器npm安装</p><ul><li>安装node.js会自带</li><li>npm中国镜像npm config set registry&#x3D;<a href="https://registry.npmmirror.com/">https://registry.npmmirror.com</a>. </li><li>npm config ls</li><li>执行npm view react看下效果</li><li>Node.js默认是CommonJs方案（因为先有Node.js，后有es6<br>分类：</li><li>系统模块</li><li>业务模块<ul><li>社区三方模块</li><li>自定义</li></ul></li></ul><p>Node.js是和Java&#x2F;Go&#x2F;C++一样，有文件，网络，系统等能力<br>Node.js主要应用场景:服务端开发(传统服务器，ServerLess)，本地工具开发，工程化工具开发Node.js模块化主要是CommonJs，也支持ESModule,未来ESModule也会是主流<br>npm不是唯一的包管理方式，还有pnpm,yarn</p><h5 id="Webpack5学习"><a href="#Webpack5学习" class="headerlink" title="Webpack5学习"></a>Webpack5学习</h5><p>打包所有的资源</p><ol><li><strong>缓存问题（dist&#x2F;main.js 文件名固定）：</strong></li></ol><ul><li>使用文件版本号：在每次文件内容变化时，可以在文件名中添加版本号或者哈希值，例如 <code>main.&lt;hash&gt;.js</code>，这样可以确保浏览器每次获取到的文件都是新的，从而避免缓存问题。</li></ul><ol start="2"><li><strong>模块化：引入 CSS 文件：</strong></li></ol><ul><li>使用模块化打包工具：如果你使用类似 Webpack 的模块化打包工具，它们通常支持引入 CSS 文件，并能够将 CSS 文件打包到最终的输出文件中。你可以使用类似 <code>style-loader</code> 或 <code>css-loader</code> 这样的 loader 来处理 CSS 文件的导入和打包。</li></ul><ol start="3"><li><strong>模块化：引入 TypeScript 文件，如何编译：</strong></li></ol><ul><li><pre><code class="hljs">TypeScript（TS）是一种由微软开发的开源编程语言，是 JavaScript 的超集，意味着所有有效的 JavaScript 代码也是有效的 TypeScript 代码。TypeScript 引入了静态类型检查，接口，类，命名空间等概念，以提高代码的可读性和维护性。<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">  <br>- 使用 TypeScript 编译器：安装 TypeScript 并创建一个 `tsconfig.json` 文件，然后运行 `tsc` 命令，它将编译 TypeScript 文件为 JavaScript。你也可以使用类似 Webpack 的工具，配置相应的 loader 来处理 TypeScript 文件。<br>  <br>   ```json<br>   // tsconfig.json<br>   &#123;<br>     <span class="hljs-string">&quot;compilerOptions&quot;</span>: &#123;<br>       <span class="hljs-string">&quot;target&quot;</span>: <span class="hljs-string">&quot;es5&quot;</span>,<br>       <span class="hljs-string">&quot;module&quot;</span>: <span class="hljs-string">&quot;commonjs&quot;</span>,<br>       <span class="hljs-string">&quot;strict&quot;</span>: <span class="hljs-literal">true</span><br>  &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></code></pre></li></ul><ol start="4"><li><strong>前后端分离时，请求跨域怎么办：</strong><ul><li><p><strong>服务器端设置跨域头：</strong> 在后端服务器的响应中添加跨域头，允许特定的域访问资源。在 Express 中，你可以使用 <code>cors</code> 中间件来处理跨域请求。</p></li><li><p>Express.js（通常简称为 Express）是一款基于 Node.js 平台的 Web 应用程序框架，它提供了一系列丰富的功能来构建 Web 和移动应用。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">   <span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">const</span> cors = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cors&#x27;</span>);<br>   <span class="hljs-keyword">const</span> app = <span class="hljs-title function_">express</span>();<br><br>   app.<span class="hljs-title function_">use</span>(<span class="hljs-title function_">cors</span>());<br><br>   <span class="hljs-comment">// Your routes and other middleware</span><br><br>   app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>     <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server is running on port 3000&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure></li><li><p><strong>代理：</strong> 在开发环境中，你可以设置代理，将前端的请求代理到后端，避免跨域问题。例如，在 Vue CLI 或 React 的 Create React App 中，你可以配置 <code>vue.config.js</code> 或 <code>package.json</code> 中的 <code>proxy</code> 字段。</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">   <span class="hljs-comment">// vue.config.js</span><br>   module.exports = <span class="hljs-punctuation">&#123;</span><br>     devServer<span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>       proxy<span class="hljs-punctuation">:</span> &#x27;http<span class="hljs-punctuation">:</span><span class="hljs-comment">//localhost:3000&#x27;</span><br>     <span class="hljs-punctuation">&#125;</span><br><span class="hljs-punctuation">&#125;</span>;<br></code></pre></td></tr></table></figure></li><li><p><strong>JSONP（仅限 GET 请求）：</strong> JSONP 是一种通过动态创建 <code>&lt;script&gt;</code> 标签实现跨域请求的方法。不过，它有一些限制，比如仅支持 GET 请求。</p></li><li><p><strong>CORS（跨域资源共享）：</strong> 在正式环境中，可以配置后端支持 CORS，允许特定的域访问资源。这需要后端和前端的配合，确保正确设置跨域请求所需的头信息。</p></li></ul></li></ol><p>Webpack核心概念:loader</p><p>webpack 只能理解JavaScript和JSON文件(其实是Node.js)，这是 webpack 开箱可用的自带能力。loader让webpack能够去处理其他类型的文件，并将它们转换为有效模块，以供应用程序使用，以及被添加到依赖图中。</p><h5 id="React开发"><a href="#React开发" class="headerlink" title="React开发"></a>React开发</h5><p>React是一个用于构建用户界面的JavaScript库，由Facebook开发和维护。它采用组件化的方式构建UI,通过虚拟DOM实现高效的页面更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">fuction <span class="hljs-title class_">HelloMessage</span>(props) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>&#125;<br></code></pre></td></tr></table></figure><p>一个简单的React组件用类似上面的代码进行定义<br>一个React组件定义为一个function(组件名建议以大驼峰进行命名)，它接收输入的数据并返回需要展示的内容。<br>在上面return关键字后面的类似XML的写法被称为JSX，被传入的数据在组件中通过props进行访问。</p><p>1．组件化: React将页面拆分成多个组件，每个组件都有自己的状态和生命周期，便于代码的复用和维护。<br>2．虚拟DOM:React通过虚拟DOM实现高效的页面更新，将修改操作转换为虚拟DOM树上的节点操作，然后批量更新DOM，减少了DOM操作的次数，提高了页面性能。</p><p>3.JSX语法: React采用JSX语法，将HTML和JavaScript混合在一起<br>使得代码更加直观和易于理解。<br>4．单向数据流:React采用单向数据流的模式，数据只能从父组件传递到子组件，子组件不能直接修改父组件的数据，保<br>证了数据的可控性。<br>5．生命周期: React组件有生命周期，可以在组件的不同阶段执行相应的操作，比如组件的创建、更新、销毁等。<br>6.组件库: React有丰富的组件库，如Ant Design、Material Ul等，可以快速搭建出漂亮、易于使用的界面。<br>7.社区支持: React有庞大的社区支持，有大量的教程、文档和开源项目可供学习和使用。</p><h5 id="组件与JSX语法"><a href="#组件与JSX语法" class="headerlink" title="组件与JSX语法"></a>组件与JSX语法</h5><p>解构函数</p><p>解构函数是指在函数参数列表中使用解构赋值的语法。这使得你可以从传递给函数的对象或数组中提取值并将其赋给函数的参数，从而更方便地处理和使用这些值。解构函数通常用于简化代码、提高可读性以及方便地使用对象和数组的属性或元素。</p><ul><li>解构对象参数：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 传递对象参数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printUserDetails</span>(<span class="hljs-params">&#123; name, age, email &#125;</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Name: <span class="hljs-subst">$&#123;name&#125;</span>, Age: <span class="hljs-subst">$&#123;age&#125;</span>, Email: <span class="hljs-subst">$&#123;email&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> user = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;John Doe&#x27;</span>,<br>  <span class="hljs-attr">age</span>: <span class="hljs-number">25</span>,<br>  <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;john@example.com&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// 调用函数并传递对象参数</span><br><span class="hljs-title function_">printUserDetails</span>(user);<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>printUserDetails</code> 函数的参数使用了对象的解构赋值，直接从传递给函数的 <code>user</code> 对象中提取了 <code>name</code>、<code>age</code> 和 <code>email</code> 属性。</p><ul><li>解构数组参数：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 传递数组参数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printNumbers</span>(<span class="hljs-params">[a, b, c]</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`a: <span class="hljs-subst">$&#123;a&#125;</span>, b: <span class="hljs-subst">$&#123;b&#125;</span>, c: <span class="hljs-subst">$&#123;c&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><br><span class="hljs-comment">// 调用函数并传递数组参数</span><br><span class="hljs-title function_">printNumbers</span>(numbers);<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>printNumbers</code> 函数的参数使用了数组的解构赋值，直接从传递给函数的 <code>numbers</code> 数组中提取了元素。</p><ul><li>默认值和重命名：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 传递带有默认值的对象参数，并使用重命名</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printUserInfo</span>(<span class="hljs-params">&#123; name, age = <span class="hljs-number">30</span>, email: userEmail &#125;</span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`Name: <span class="hljs-subst">$&#123;name&#125;</span>, Age: <span class="hljs-subst">$&#123;age&#125;</span>, Email: <span class="hljs-subst">$&#123;userEmail&#125;</span>`</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> userInfo = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Alice&#x27;</span>,<br>  <span class="hljs-attr">email</span>: <span class="hljs-string">&#x27;alice@example.com&#x27;</span><br>&#125;;<br><br><span class="hljs-comment">// 调用函数并传递对象参数</span><br><span class="hljs-title function_">printUserInfo</span>(userInfo);<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>printUserInfo</code> 函数的参数使用了对象的解构赋值，其中 <code>age</code> 设置了默认值，而 <code>email</code> 被重命名为 <code>userEmail</code>。</p><p>解构函数使得代码更加简洁，并提高了可读性，特别是在处理复杂的对象和数组参数时。这个特性在现代 JavaScript 开发中得到广泛应用。</p><h5 id="JSX语法-列表渲染"><a href="#JSX语法-列表渲染" class="headerlink" title="JSX语法-列表渲染"></a>JSX语法-列表渲染</h5><h5 id="JSX语法-条件渲染"><a href="#JSX语法-条件渲染" class="headerlink" title="JSX语法-条件渲染"></a>JSX语法-条件渲染</h5><h5 id="组件的状态和属性"><a href="#组件的状态和属性" class="headerlink" title="组件的状态和属性"></a>组件的状态和属性</h5><h5 id="组件间传值"><a href="#组件间传值" class="headerlink" title="组件间传值"></a>组件间传值</h5><h5 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h5><p>Hook，又称钩子。是React 16.8的新增属性，它可以让我们在不编写class的情况下使用state以及其他的React特性，Hook就相当于添加了内部状态的函数式组件，Hook已经目前前端的主流开发方式，Vue3中也引入了类似的特性，在后面的项目中我们会全面使用Hook。</p><ul><li>Hook相对于之前的Class写法有以下几点好处:</li></ul><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-number">1.</span>更简单的复用组件的内部逻辑以及状态<br><span class="hljs-number">2.</span>简单的生命周期逻辑<br><span class="hljs-number">3.</span>无需使用<span class="hljs-keyword">class</span><br></code></pre></td></tr></table></figure><p>Hook就是可以让你在函数式组件内部“钩入”React state以及生命周期等特性的函数，Hook 不能在类组件中使用。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">useState</span><br><span class="hljs-attribute">useEffect</span><br><span class="hljs-attribute">useRef</span><br><span class="hljs-attribute">useCallback</span><br><span class="hljs-attribute">useMemo</span><br></code></pre></td></tr></table></figure><h5 id="全栈开发基础"><a href="#全栈开发基础" class="headerlink" title="全栈开发基础"></a>全栈开发基础</h5><p>01 Http协议<br>02Node.js基础<br>03 Node.js常见模块</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dos"><span class="hljs-built_in">fs</span>模块(<span class="hljs-built_in">fs</span>-extra模块)<br><span class="hljs-built_in">path</span>模块<br>http模块<br>child process模块<br>os模块<br>cluster模块<br>cross-env模块，axios模块,dateFormat模块<br></code></pre></td></tr></table></figure><h5 id="Koa模块介绍"><a href="#Koa模块介绍" class="headerlink" title="Koa模块介绍"></a>Koa模块介绍</h5><ul><li>为什么要用框架</li></ul><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">Node.js原生http功能过于基础<br>路由<span class="hljs-regexp">/缓存/</span>cookie<span class="hljs-regexp">/http头/</span>状态码/静态文件等各种功能没有<br></code></pre></td></tr></table></figure><ul><li>常用web开发框架</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">express/koa同一个团队开发<br>Egg<span class="hljs-number">.</span><span class="hljs-keyword">js</span> 基于koa,约定优于配置,多进程模型<br>NestJS基于express,高效可扩展的Node<span class="hljs-number">.</span><span class="hljs-keyword">js</span>服务端框架。对ts支持比较好。<br>Next<span class="hljs-number">.</span><span class="hljs-keyword">js</span>/Nuxt<span class="hljs-number">.</span><span class="hljs-keyword">js</span> 基于React/Vue的SSR开发框架<br></code></pre></td></tr></table></figure><ul><li>Koa模块介绍</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">App:</span>应用<br><span class="hljs-symbol">Context:</span>处理http请求上下文<br><span class="hljs-symbol">Request:</span>请求<br><span class="hljs-symbol">Response:</span>响应<br></code></pre></td></tr></table></figure><h5 id="前端面试"><a href="#前端面试" class="headerlink" title="前端面试"></a>前端面试</h5><p><a href="https://zhuanlan.zhihu.com/p/605933425"></a></p><h4 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h4><p>一些json，渲染，内置组件，api。</p><p><a href="https://blog.csdn.net/m0_64875238/article/details/127796691">https://blog.csdn.net/m0_64875238/article/details/127796691</a></p><h4 id="IOS"><a href="#IOS" class="headerlink" title="IOS"></a>IOS</h4><p>AppDelegate.swift文件</p><p>ViewController.swift 视图控制器</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo配置</title>
    <link href="/2024/01/26/hexo%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/01/26/hexo%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>[官网手册](<a href="https://fluid-dev.github.io/hexo-fluid-docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97">https://fluid-dev.github.io/hexo-fluid-docs/guide/#%E5%85%B3%E4%BA%8E%E6%8C%87%E5%8D%97</a></p><p>#####)</p><h5 id="更改主页照片"><a href="#更改主页照片" class="headerlink" title="更改主页照片"></a>更改主页照片</h5><p>更改_config.fluid.yml里面的</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">今天莫名hexo d报错：ssh: <span class="hljs-keyword">connect</span> <span class="hljs-keyword">to</span> host github.com port <span class="hljs-number">22</span>: <span class="hljs-keyword">Connection</span> timed <span class="hljs-keyword">out</span> fatal: Could <span class="hljs-keyword">not</span> <span class="hljs-keyword">read</span> <span class="hljs-keyword">from</span> remote repository.<br>尝试删除ssh密钥重新配置，大小写是否错误等还是不行<br><br>ssh -T git@github.com 也报错<br><br>最后解决方案：https://blog.csdn.net/nightwishh/article/details/<span class="hljs-number">99647545</span><br>在.ssh文件下面创建vim config<br>输入：<br>Host github.com<br><span class="hljs-keyword">User</span> 注册github的邮箱<br>Hostname ssh.github.com<br>PreferredAuthentications publickey<br>IdentityFile ~/.ssh/id_rsa<br>Port <span class="hljs-number">443</span><br><br><br></code></pre></td></tr></table></figure><h5 id="基本操作语句"><a href="#基本操作语句" class="headerlink" title="基本操作语句"></a>基本操作语句</h5><p>在D:\myblog\hexo目录 git bash here</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs axapta">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;name&quot;</span>       <span class="hljs-meta"># 新建文章</span><br>hexo <span class="hljs-keyword">new</span> page <span class="hljs-string">&quot;name&quot;</span>  <span class="hljs-meta"># 新建页面</span><br>hexo g                <span class="hljs-meta"># 生成页面</span><br>hexo d                <span class="hljs-meta"># 部署</span><br>hexo g -d             <span class="hljs-meta"># 生成页面并部署</span><br>hexo s                <span class="hljs-meta"># 本地预览</span><br>hexo clean            <span class="hljs-meta"># 清除缓存和已生成的静态文件</span><br>hexo help             <span class="hljs-meta"># 帮助</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>文献阅读</title>
    <link href="/2024/01/06/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/"/>
    <url>/2024/01/06/%E6%96%87%E7%8C%AE%E9%98%85%E8%AF%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="zotero插件安装"><a href="#zotero插件安装" class="headerlink" title="zotero插件安装"></a>zotero插件安装</h2><p><a href="https://imgse.com/i/pizCAII"><img src="https://s11.ax1x.com/2024/01/06/pizCAII.png" alt="pizCAII.png"></a></p><p>注意事项：</p><ul><li><p>zotero版本可能与插件不匹配，可以调整插件或zotero版本</p></li><li><p>gtp插件使用时，不能开梯子</p></li><li><p>gtp插件快捷键 Ctrl+&#x2F; 退出Esc</p></li><li><p>全文翻译 用到zotero-style是需要调用PDF Translate 和Better Notes 才能实现全文翻译，匹配zetero 6 的zotero-style， 快捷键Shift+P，</p></li></ul><h2 id="文献阅读方法"><a href="#文献阅读方法" class="headerlink" title="文献阅读方法"></a>文献阅读方法</h2><h3 id="怎么系统的阅读文献"><a href="#怎么系统的阅读文献" class="headerlink" title="怎么系统的阅读文献"></a>怎么系统的阅读文献</h3><p>分类：</p><p>一、综述类文献 review article</p><p>二、研究类文章 research article</p><p>三、方法学的文章</p><p><strong>阅读顺序</strong>：</p><p>中文综述-英文综述-中文论文-英文论文</p><p>先搜中文文献，知名专家，引用率高的，</p><p>1了解自己要研究什么</p><p>2学术圈有哪些方法</p><p>3熟悉相关专业名词、技术路线</p><p>以便于：</p><p>1选好关键词（找得好&#x2F;全）</p><p>2读英文论文有熟悉感，提高阅读速度</p><p><strong>找文献</strong>：</p><p>1国外大牛及其研究组论文</p><p>2关键词的排列组合，找到引用率高的，影响因子高的，重点关注近5年文献</p><p><strong>如何读</strong>：</p><p>粗读-精读-复现</p><p><strong>粗读</strong>：</p><p>1、看标题和摘要</p><p>1）从<strong>标题</strong>判断（比如论文是提出算法&#x2F;构建模型&#x2F;综述）</p><p>2）<strong>摘要</strong>是全文浓缩，关键词this paper前的内容都是背景，可以不看，propose和present是本文提出的方法和观点，有几个序数词就是论文分为几步，最后找result、examples即论文得到什么结果，用几个例子验证结果。</p><p>2、结论</p><p>论文最后，参考文献前的就是结论。</p><p>结论会先在此总结本文理论方法和如何操作的，然后给出结果，说这个方法好不好用。however后面是有不足的，future是未来还可以改进—如果能改进，就可以发新论文了。</p><p>3、图&#x2F;表</p><p>适用于已经读了一些论文，有基础的同学。单看图表就能推测论文内容。</p><p><strong>精读</strong></p><p>读懂作者的研究思路&#x2F;方法，重要的地方标出来做笔记。利用翻译软件快速读通、读懂。重要单词会反复出现的。</p><p>多看几次自然就记住了。</p><p>只出现一次的陌生单词可以利用翻译软件。但<strong>不要一边记新单词一边看论文。这样会搞不懂论文到底讲了什么。</strong>实在看不懂就暂时放下，等看过一定量的论文后，回头再看就不难了。</p><p><strong>复现</strong></p><p>选1-3篇论文，沿着作者的思路，执行他的实验过程。看能否得到一样的实验结果。</p><p>复现不仅能掌握试验方法，学会用图表分析实验结果。对后续自己的实验也有帮助。还能在过程中找到新思路和突破点，说不定可以直接发新文章了。</p><p>读论文不仅要读内容，还要读逻辑，学习写作套路，逻辑比内容更重要。</p><p>看文献要<strong>集中时间</strong>。把多个论文联系起来整体把握。看文献时间越分散，浪费的时间就越多。</p><h3 id="常用的统计知识"><a href="#常用的统计知识" class="headerlink" title="常用的统计知识"></a>常用的统计知识</h3><h4 id="SPSS分析"><a href="#SPSS分析" class="headerlink" title="SPSS分析"></a>SPSS分析</h4><p><a href="https://zhuanlan.zhihu.com/p/640429274">https://zhuanlan.zhihu.com/p/640429274</a></p><ul><li>1、基本描述统计<ul><li>频数分析：用于分析定类数据的选择频数和百分比分布。</li><li>描述分析：用于分析定量数据的集中趋势、波动情况和分布状况等；常见的指标有平均值、中位数、标准差等；更深入的描述指标包括百分位数、峰度、偏度、变异系数等。</li><li>分类汇总：用于交叉研究，展示两个或者更多变量的交叉信息，可以将不同组别下的数据进行汇总统计。</li></ul></li><li>2、信度分析<ul><li>Cronbach α信度：最常使用的方法，通过Cronbach α信度系数测量测验或量表的信度是否达标。</li><li>折半信度：是将所有量表题项分为两半，计算两部分各自的信度以及相关系数，进而估计整个量表的信度的测量方法</li><li>重测信度：是指同一批样本，在不同时间点做了两次相同的问题，然后计算两次回答的相关系数，通过相关系数去研究信度水平。</li></ul></li><li>3、效度分析<ul><li>内容效度：用文字描述量表的有效性，比如具有参考文献来源，量表经过专家认可等。</li><li>结构效度：因子与测量项对应关系是否符合预期，如果符合预期则说明具有结构效度。</li><li>区分效度：强调本不应该在同一因子下的测量项，确实不在同一因子下面。</li><li>聚合效度：强调本应该在同一因子下面的测量项，确实在同一因子下面。</li></ul></li><li>4、差异关系研究<ul><li>t 检验：X为定类数据，Y为定量数据之间的关系情况，且X只能为2个类别。</li><li>方差分析：X为定类数据，Y为定量数据，且组别多于2组时可使用方差分析。</li><li>交叉卡方：分析定类数据和定类数据之间的关系情况，可使用交叉卡方分析。</li><li>非参数检验：数据不正态或者方差不齐时，可使用非参数检验。</li></ul></li><li>5、t检验<ul><li>单样本t检验：对比一组定量数据与某个数字的差异。</li><li>独立样本t检验：对比X定类数据与Y定量数据之间的差异。</li><li>配对t检验：对比两组配对数据之间的差异。</li></ul></li><li>6、方差分析<ul><li>单因素方差分析：如果X为一个，则使用单因素方差分析。</li><li>双因素方差分析：当X个数为2个，则使用双因素方差分析。</li><li>多因素方差分析：当X个数超过2个，使用多因素方差分析。</li><li>事后多重比较：是基于方差分析基础上进行，如果X的组别超过两组，可用事后多重比较进一步分析两两组别之间的差异。</li><li>协方差分析：如果研究中有干扰因素（控制变量），可使用协方差分析。</li><li>重复测量方差分析：相关领域（比如医学研究时）常常需要对同一观察单位重复进行多次测量，此时使用重复测量方差分析。</li></ul></li><li>7、卡方检验<ul><li>卡方检验：定类数据与定类数据之间的差异情况。</li><li>配对卡方：两组配对定类数据之间的差异情况。</li><li>卡方拟合优度：研究类别定类数据的实际比例与预期比例是否一致。</li><li>分层卡方：分层卡方是在卡方检验基础上，进一步考虑分层项的干扰。</li><li>Fisher卡方：在分析样本量较少（比如小于40），也或者期望频数出现小于5时，使用fisher卡方检验较为适合。</li></ul></li><li>8、非参数检验<ul><li>单样本Wilcoxon检验：是当数据不服从正态分布时，可检验数据是否与某数字是否有明显的区别。</li><li>MannWhitney：对于不服从正态分布的变量进行差异性分析，如果X的组别为两组，则使用MannWhitney统计量。</li><li>Kruskal-Wallis：如果组别超过两组，则应该使用Kruskal-Wallis统计量。</li><li>配对样本Wilcoxon检验：如果是配对数据，则使用配对样本Wilcoxon检验。</li><li>多样本Friedman检验&#x2F;Cochran’s Q 检验：对于多个关联样本的差异情况。</li><li>Ridit分析：如果是研究定类数据与定量（等级）数据之间的差异性，还可以使用Ridit分析。</li></ul></li><li>9、相关分析研究<ul><li>相关分析：简单相关分析是分析对两个变量之间的相关关系。</li><li>偏相关分析：当两个变量都与第三个变量相关时，为了消除第三个变量的影响，只关注这两个变量之间的关系情况，此时可使用偏相关分析。</li><li>典型相关分析：研究两组变量（多个指标组成）之间的整体相关性，可用典型相关分析。</li></ul></li><li>10、线性回归研究<ul><li>线性回归：研究X对Y（定量数据）的影响关系情况。</li><li>逐步回归：如果X很多时，可使用逐步回归自动找出有影响的X。</li><li>岭回归：用于解决线性回归中自变量共线性的研究算法。</li><li>分层回归：如果需要研究多个线性回归的层叠变化情况，此时可使用分层回归。</li><li>Robust回归：如果数据中有异常值，可使用Robust回归进行研究。</li></ul></li><li>11、logistic回归研究<ul><li>二元logit回归：Y为定类数据且只有两类</li><li>多分类logit：Y为定类数据且大于2类</li><li>有序logit：Y为定类数据且有序</li></ul></li><li>12、多选题研究<ul><li>多选题分析：是针对单个多选题的分析方法，可分析多选题各项的选择比例情况。</li><li>单选-多选：是针对X为单选，Y为多选的情况使用的方。</li><li>多选-单选：是针对X为多选，Y为单选的情况使用的方法。</li><li>多选-多选：是针对X为多选，Y为多选的情况使用的方法</li></ul></li><li>13、聚类分析方法<ul><li>K-means聚类：只能处理数值型数据。</li><li>K-modes聚类：对分类属性数据进行聚类的方法。</li><li>K-prototype聚类：处理混合属性数据的方法。</li><li>分层聚类：对给定数据对象的集合进行层次分解，根据分层分解采用的分解策略，仅针对定量数据进行分层聚类。</li></ul></li><li>14、信息浓缩方法<ul><li>主成分分析和因子分析：都是信息浓缩的方法，即将多个分析项信息浓缩成几个概括性指标。如果希望进行将指标命名，SPSSAU建议使用因子分析。原因在于因子分析在主成分基础上，多出一项旋转功能，该旋转目的即在于命名。</li><li>平均值和求和：也是信息浓缩的常用方法，比如要将多个题项合并成一个变量，可通过求平均值概括成一个题项。</li><li>中位数：当数据不满足正态，存在极端值时，可用中位数代替平均值。</li></ul></li><li>15、一致性研究方法<ul><li>ICC组内相关系数：用于分析多次数据的一致性情况，分析定量或定类数据均可。</li><li>Kappa一致性检验：适用于两次方法之间比较一致性，通常要求数据为定类数据。</li><li>Kendall协调系数：分析多个数据之间关联性的方法，适用于定量数据，尤其是定序等级数据。</li></ul></li><li>16、权重研究<ul><li>AHP层次分析法：是一种主观加客观赋值的计算权重的方法。先通过专家打分构造判断矩阵，然后量化计算每个指标的权重。</li><li>熵值法：是利用熵值携带的信息计算每个指标的权重，通常可配合因子分析或主成分分析得到一级权重，利用熵值法计算二级权重。</li><li>TOPSIS法：是一种评价多个样本综合排名的方法，用于比较样本的排名情况。</li><li>因子分析：可将多个题项浓缩成几个概括性指标（因子），然后对新生成的各概括性指标计算权重。</li><li>主成分分析：利用方差解释率值计算各概括性指标的权重。</li><li>其他：熵权topsis法、优序图法、CRITIC权重、独立性权重、信息量权重等。</li></ul></li><li>17、模型研究方法<ul><li>线性回归：当研究X对Y的影响关系，其中Y为定量数据，可使用线性回归分析。</li><li>logistic回归：研究X对Y的影响关系，其中Y为定类数据，可使用Logistic分析。</li><li>典型相关：研究1组X与一组Y之间的关系情况，可使用典型相关分析。</li><li>PLS回归：研究多个X与多个Y之间的影响关系情况，且样本量较小（通常小于200），可使用PLS回归分析。</li><li>路径分析：如需分析多个X对多个Y的影响关系，以及具体哪些X对哪些Y有影响、如何影响，可使用路径分析。</li><li>结构方程模型：需要同时研究测量关系和影响关系，可使用结构方程模型。</li></ul></li><li>18、数据分布研究<ul><li>正态性：很多分析方法的使用前提都是要求数据服从正态性，比如线性回归分析、相关分析、方差分析等，可通过直方图、P-P&#x2F;Q-Q图、正态性检验查看数据正态性。</li><li>随机性：抽样调查有一个最基本的前提假设，就是抽样必须满足“随机性要求”，游程检验是一种非参数性统计假设的检验方法，可用于分析数据是否为随机。</li><li>方差齐性：方差齐检验用于分析不同定类数据组别对定量数据时的波动情况是否一致，即方差齐性。方差齐是方差分析的前提，如果不满足则不能使用方差分析。</li><li>卡方拟合优度检验：卡方拟合优度检验是一种非参数检验方法，其用于研究实际比例情况，是否与预期比例表现一致，但只针对于类别数据。</li><li>Poisson分布：如果要判断数据是否满足Poisson分布，可通过Poisson检验判断或者通过特征进行判断是否基本符合Poisson分布（三个特征即：平稳性、独立性和普通性）</li></ul></li><li>19、机器学习<ul><li>决策树：常用于研究类别归属和预测关系的模型。</li><li>随机森林：实质上是多个决策树模型的综合，决策树模型只构建一棵分类树，但是随机森林模型构建非常多棵决策树。</li><li>KNN：是一种简单易懂的机器学习算法，其原理是找出挨着自己最近的K个邻居，并且根据邻居的类别来确定自己的类别情况。</li><li>朴素贝叶斯：是基于贝叶斯定量，并且加上条件（特征之间独立）的一种模型。</li><li>支持向量机：是一种二分类模型。</li><li>神经网络：是一种模拟人脑神经思维方式的数据模型。</li></ul></li><li>20、可视化分析方法<ul><li>散点图：用于考察定量数据之间的关系情况。</li><li>箱线图：直观地识别数据中的异常值、判断数据离散分布情况。</li><li>误差线图：用于展示数据的不确定性程度，显示潜在的误差或每个数据标志的不确定程度。</li><li>ROC曲线：用于研究X对Y的预测准确率情况。</li><li>其他：P-P图&#x2F;Q-Q图、直方图、象限图、帕累托图、簇状图、气泡图、核密度图、小提琴图等。</li></ul></li></ul><h4 id="检验"><a href="#检验" class="headerlink" title="检验"></a>检验</h4><h6 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h6><ul><li><p>参数检验（正态分布）</p><ul><li>T检验</li><li>单样本T检验</li><li>独立样本T检验</li><li>配对T检验</li><li>方差分析（常用于大于两组的多组数据的差异分析）<ul><li>单因素方差分析</li><li>两因素方差分析</li></ul></li></ul></li><li><p>非参数检验（能适用于更复杂的数据分布情境）</p><ul><li>秩和检验</li><li>wilcoxon秩和检验：适用于两组数据比较</li><li>KW秩和检验：适用于多组数据比较。</li><li>卡方检验<ul><li>2*2</li><li>2*C</li><li>R*C</li></ul></li></ul></li></ul><h6 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h6><p><img src="D:\pic\typora_pic\image-20241028153233617.png" alt="image-20241028153233617"></p><p>计量资料，计数资料，等级资料</p><p>正态分布：SPSS提供多种，常用W 检验（当N≤2000，一般满足正态分布，P&gt;0.05)、D 检验（N&gt;2000)。</p><p>方差齐性：Levene’s检验，P&gt;0.05</p><p>等级资料：秩和检验（构成比分布、分布轮廓）、卡方检验（分布位置差异）选哪个？大多数秩和检验、不绝对。</p><h4 id="如何看箱线图"><a href="#如何看箱线图" class="headerlink" title="如何看箱线图"></a>如何看箱线图</h4><img src="D:\pic\typora_pic\image-20241028160308802.png" alt="image-20241028160308802" style="zoom:33%;" /><h4 id="数据的一致性分析"><a href="#数据的一致性分析" class="headerlink" title="数据的一致性分析"></a>数据的一致性分析</h4><p>Kappa 系数</p><p>Kendall 协调系数</p><p>ICC组内相关系数</p><p>针对<strong>连续型定量</strong>资料的一致性评价，目前 <strong>Bland-Altman 图</strong>是比较流行的<strong>图形检验</strong>方法。</p><p>Bland Altman 图简称 BA图，是一种定量测量结果一致性检验的图示化方法，该方法可以对<strong>两次观测或两种方法、设备定量测量数据</strong>进行一致性评价。</p><p>其基本思想是充分利用两组定量测量数据的<strong>平均值和差值</strong>数据信息。</p><h4 id="汇报"><a href="#汇报" class="headerlink" title="汇报"></a>汇报</h4><h5 id="睡眠可穿戴设备准确性对比"><a href="#睡眠可穿戴设备准确性对比" class="headerlink" title="睡眠可穿戴设备准确性对比"></a>睡眠可穿戴设备准确性对比</h5><p>与阻塞性睡眠呼吸暂停患者同时进行的多导睡眠图检查相比，家用睡眠脑电图设备睡眠分期准确性的验证</p><ul><li>DOI：10.1038&#x2F;s41598-024-53827-1。</li></ul><p>在实验室中，为简化标准多导睡眠图 (PSG)，尤其是针对阻塞性睡眠呼吸暂停 (OSA) 以及评估其与便携式脑电图 (EEG) 设备的一致性所做的努力有限。我们旨在评估便携式 EEG 设备与 OSA 患者的 I 型 PSG 之间的一致性，并检查基于 EEG 的觉醒指数估计呼吸暂停严重程度的能力。我们招募了 <strong>77 名日本 OSA 患者</strong>，让他们<strong>同时接受 I 型 PSG 和便携式 EEG 监测。结合脉搏率、血氧饱和度 (SpO 2 ) 和 EEG 可提高睡眠分期准确性</strong>。<strong>Bland-Altman 图、配对 t 检验</strong>和受试者<strong>操作特性曲线</strong>用于评估一致性和筛查准确性。在总睡眠时间、睡眠潜伏期、入睡后觉醒、睡眠效率、N1、N2 和 N3 率、觉醒指数和呼吸暂停指数方面观察到明显的小偏差。所有变量在 Bland-Altman 分析中均表现出 &gt; 95% 的一致性，组间相关系数为 0.761-0.982，表明仪器间效度较高。基于 EEG 的唤醒指数显示出足够的能力来筛查 AHI ≥ 15 和 ≥ 30，并在预测呼吸暂停严重程度方面取得了令人鼓舞的结果。便携式 EEG 设备与 OSA 患者的 I 型 PSG 显示出<strong>高度一致性</strong>。这些表明 OSA 患者可以在家中评估自己的病情。</p><ul><li><p>涉及的专业名词：氧去饱和指数 [ODI]、呼吸暂停低通气指数 [AHI] 和呼吸事件指数 [REI]</p></li><li><p>涉及的统计：</p></li></ul><p>使用 Bland–Altman 分析比较每种设备，显示与 I 型 PSG 和便携式 EEG 设备相比的个体夜间差异。该分析还呈现了偏差的总体水平和 LOA。使用具有统计学意义的配对 t 检验来评估偏差。此外，还计算了两种设备的 ICC 和 95％ 置信区间 (CI)。ICC 值 &gt; 0.75、0.40–0.75 和 &lt; 0.40 分别表示非常好、一般到好和差<a href="https://www.nature.com/articles/s41598-024-53827-1#ref-CR41">41。</a>此外，对每台设备的所有 30 秒时期进行了逐个时期的分析。该分析涉及参考先前的研究计算准确度、灵敏度、特异性、患病率和偏倚调整 kappa (PABAK) <a href="https://www.nature.com/articles/s41598-024-53827-1#ref-CR42">42</a>。</p><p>进行受试者工作特征 (ROC) 曲线分析，以探讨唤醒指数在筛查呼吸暂停方面的潜力。该分析以中度 (AHI ≥ 15) 和重度 (AHI ≥ 30) 呼吸暂停作为因变量，同时调整性别、年龄、BMI 和使用便携式 EEG 设备测量的唤醒指数等自变量。计算了 AUC、准确度、灵敏度和特异性。</p><p>使用 R 软件（奥地利维也纳统计计算基金会）进行 Bland–Altman 和逐个时期分析，使用 SPSS 26.0 版（美国纽约州阿蒙克 IBM 公司）进行 ICC 和 ROC 曲线分析。双尾统计学显著性设定为<em>P</em> &lt; 0.05（双尾）。</p><p><strong>Bland–Altman分析</strong>：这是用于比较两种测量方法一致性的方法，显示个体的测量值之差（偏差）和一致性范围（LOA，限度范围）。在 Bland–Altman 图上，每个点表示两种设备对同一测量的差异，可以直观地查看偏差是否显著。</p><p><strong>LOA（限度范围，Limits of Agreement）</strong>：表示 Bland–Altman 分析中偏差的范围，通常计算平均差值加减 1.96 个标准差（假设数据正态分布），从而反映设备间差异的总体水平。</p><p><strong>配对t检验</strong>：用于比较两种设备测量的均值差异是否有统计学意义。配对 t 检验用于对同一受试者的两种设备数据进行比较，检测是否存在系统性偏差。</p><p><strong>ICC（组内相关系数，Intraclass Correlation Coefficient）</strong>：这是衡量不同设备测量值一致性的指标，值的范围从 0 到 1。ICC 大于 0.75 表示非常好，0.40-0.75 表示一般到好，小于 0.40 表示一致性差。</p><p><strong>95%置信区间（CI，Confidence Interval）</strong>：表示估计值的精确度区间。ICC 的 95% CI 显示了 ICC 的可能范围，表示在95%置信水平下，真实值会落在该区间内。</p><p><strong>灵敏度和特异性</strong>：分别表示检测阳性和阴性的准确性。灵敏度是设备检测阳性（如呼吸暂停）的概率，特异性是检测阴性（无呼吸暂停）的概率。</p><p><strong>偏倚调整 kappa（PABAK，Prevalence and Bias Adjusted Kappa）</strong>：用于衡量两台设备在不同条件下的分类一致性，调整了患病率和偏倚对 kappa 系数的影响。kappa 系数用来评估分类数据的一致性，偏倚调整后的 kappa 更能反映真实一致性。</p><p><strong>受试者工作特征（ROC，Receiver Operating Characteristic）曲线</strong>：评估分类器（如设备检测呼吸暂停）的表现。ROC曲线下的面积（AUC，Area Under Curve）反映了分类器的整体性能，AUC越接近1越好。</p><p><strong>AUC（曲线下面积，Area Under Curve）</strong>：ROC曲线下的面积，表示设备在筛查呼吸暂停的效果。AUC 值接近 1 表示高准确度，值越小则准确度越低。</p><p><strong>双尾统计显著性</strong>：假设检验的一种方式，P &lt; 0.05 表示结果具有统计学意义，表示偏差或差异不是偶然出现。</p><p>三种商用可穿戴设备对健康成年人睡眠追踪的准确度</p><ul><li>DOI: <a href="https://doi.org/10.3390/s24206532">10.3390&#x2F;s24206532</a></li></ul><p>消费者对睡眠追踪的使用越来越普遍；然而，很少有研究评估过此类设备的准确性。我们试图评估三种设备（Oura Ring Gen3、Fitbit Sense 2 和 Apple Watch Series 8）<strong>与黄金标准睡眠评估（多导睡眠图 (PSG)）的准确性</strong>。<strong>35 名没有睡眠障碍的参与者</strong>（年龄 20-50 岁）参加了一项为期一晚的住院研究，在此期间他们佩戴 Oura Ring、Fitbit 和 Apple Watch，并接受 PSG 监测。对于检测睡眠与清醒，所有设备的灵敏度均为≥95%。对于区分睡眠阶段，灵敏度范围为 50% 至 86%，如下所示：Oura Ring 灵敏度为 76.0-79.5%，精确度为 77.0-79.5%；Fitbit 灵敏度为 61.7-78.0%，精确度为 72.8-73.2%；和 Apple 灵敏度 50.5-86.1% 和精确度 72.7-87.8%。Oura 戒指在清醒、浅睡眠、深度睡眠或 REM 睡眠估计方面与 PSG 没有区别。Fitbit 高估了浅睡眠（18 分钟；<em>p</em> &lt; 0.001）并低估了深度睡眠（15 分钟；<em>p &lt; 0.001）。Apple 低估了清醒（7 分钟；</em> <em>p</em> &lt; 0.01）和深度睡眠（43 分钟；<em>p</em> &lt; 0.001）的持续时间，并高估了浅睡眠（45 分钟；<em>p</em> &lt; 0.001）。对于睡眠健康的成年人，所有设备在睡眠时间的估计方面都与 PSG 相似，并且设备也与 PSG 衍生的睡眠阶段显示出中度到高度的一致性。</p><p><strong>关键词：</strong> Apple Watch；Fitbit；Oura 戒指；消费者睡眠追踪设备；多导睡眠图；睡眠技术；验证。</p><p>使用基于脑电图的可穿戴设备进行睡眠评估 - 系统评价</p><ul><li>DOI： <a href="https://doi.org/10.1016/j.smrv.2024.101951">10.1016&#x2F;j.smrv.2024.101951</a></li></ul><p>多导睡眠图 (PSG) 是睡眠测量的参考标准，但对参与者来说负担很重且劳动密集。价格实惠的基于脑电图 (EEG) 的可穿戴设备易于使用且越来越受欢迎，但选择最合适的设备对临床医生和研究人员来说是一个挑战。在本系统综述中，我们旨在全面概述可用于测量人类睡眠的基于 EEG 的可穿戴设备。对于每种可穿戴设备，我们将提供有关经过验证的人群和报告的测量属性的概述。在数据库 OVID MEDLINE、Embase.com 和 CINAHL 中进行了系统搜索。使用机器学习算法 (ASReview) 筛选标题和摘要以确定是否符合条件。总共选出了 60 篇论文，涵盖 34 种独特的基于 EEG 的可穿戴设备。可行性研究表明<strong>耐受性好、依从性高、成功率高</strong>。纳入的 42 项验证研究针对不同人群进行，在<strong>睡眠分期检测方面始终表现出很高的准确性</strong>。因此，基于 EEG 的可穿戴设备的最新进展显示出作为 PSG 和家庭睡眠监测替代品的巨大潜力。用户应考虑用户友好性、舒适性和成本等因素，因为这些设备的功能和价格各不相同，会影响它们是否适合个人需求。</p><p><strong>关键词：</strong> EEG；脑电图；睡眠；睡眠评估；系统评价；可穿戴设备。</p><p>接受舌下神经刺激的患者中家用睡眠设备与睡眠研究测试的比较</p><ul><li>DOI: <a href="https://doi.org/10.1002/lary.31710">10.1002&#x2F;lary.31710</a></li></ul><p><strong>目标：</strong> <strong>舌下神经刺激</strong> (HGNS) 是一种可植入的阻塞性睡眠呼吸暂停 (OSA) 疗法。目前，治疗效果是通过正式的睡眠研究来确认的，患者在家中根据自己对设备的主观体验进行经验性调整。家庭纵向呼吸暂停低通气指数 (AHI) 测量有可能通过客观数据来改进 HGNS 治疗幅度选择。我们的目标是比较新 HGNS 接受者中常规睡眠研究和两种不同家庭睡眠设备得出的 AHI。</p><p><strong>方法：</strong> 前瞻性入选的接受 HGNS 治疗的患者获得睡眠跟踪垫（Withings，法国伊西莱穆利诺）和 NightOwl 外周动脉张力计 (PAT) 传感器（Ectosense，比利时鲁汶），用于植入后 1 至 6 个月的纵向家庭 AHI 监测。在植入后 3 个月和 6 个月<strong>使用实验室多导睡眠图 (PSG) 或家庭睡眠呼吸暂停测试 (HSAT) 评估治疗效果</strong>。将睡眠垫和 PAT 传感器 AHI 与 PSG 和 HSAT 进行比较，以准确识别 OSA 严重程度。</p><p><strong>结果：</strong> 5 个中心共招募了 60 名患者，并进行了为期 6 个月的随访。睡眠垫对识别 AHI &lt;15 的敏感性和特异性分别为 61% 和 82%，对 AHI &lt;30 的敏感性和特异性分别为 77% 和 100%。PAT 设备对识别 AHI &lt;15 的敏感性和特异性分别为 57% 和 77%，对 AHI &lt;30 的敏感性和特异性分别为 81% 和 80%。</p><p><strong>结论：</strong> 睡眠垫和 PAT 传感器对检测接受 HGNS 治疗的患者中的轻度和中度 OSA 表现出高灵敏度和特异性，并且可以在家庭环境中对 HGNS 疗效进行纵向客观监测。</p><p><strong>证据级别：</strong> 3 喉镜，2024 年。</p><p><strong>关键词：</strong> 舌下神经刺激；阻塞性睡眠呼吸暂停；睡眠设备。</p><p>便携式睡眠监测仪对儿童睡眠呼吸暂停的诊断准确性：系统评价</p><p>DOI:<a href="https://doi.org/10.1016/j.smrv.2024.101991">https://doi.org/10.1016/j.smrv.2024.101991</a></p><p>近年来，已经开发出大量新型 III 型和 IV 型便携式睡眠监测仪 (PSM)，但关于它们用于儿童的诊断准确性的证据仍然不一致。本研究系统地回顾了有关 III 型和 IV 型 PSM 对儿童睡眠呼吸暂停的诊断准确性的文献。使用 PRISMA 框架审查了 Medline、Embase 或 Web of Science 中索引的出版物。在 1054 项研究中，有 62 项符合纳入标准。在评估基于血氧测定的 IV 型 PSM 的研究中，一项 (6.25%) 显示出一组平衡的高 (≥80%) <strong>敏感性和特异性</strong>，用于诊断任何儿童睡眠呼吸暂停，而五项研究（27.8%）显示出对中度至重度睡眠呼吸暂停的相似准确性。对于非基于血氧测定的 IV 型 PSM，两项研究（40%）报告了一组平衡的中度至重度睡眠呼吸暂停的高诊断准确性。 III 型 PSM 反复表现出更高的诊断准确率，其中六项研究 (66.7%) 报告了中度至重度睡眠呼吸暂停的均衡高诊断准确率。本综述强调了 III 型 PSM 检测中度至重度儿童睡眠呼吸暂停的潜力，尽管目前的证据有限，不足以支持单独使用 IV 型 PSM 来诊断大多数儿童的睡眠呼吸暂停。</p><h5 id="睡眠破碎化-comisa相关文献"><a href="#睡眠破碎化-comisa相关文献" class="headerlink" title="睡眠破碎化&amp;comisa相关文献"></a>睡眠破碎化&amp;comisa相关文献</h5><p>失眠与睡眠呼吸暂停共病（COMISA）的临床特征与治疗效果：定性和定量分析的证据</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓项目开发</title>
    <link href="/2023/12/26/%E5%AE%89%E5%8D%93%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/"/>
    <url>/2023/12/26/%E5%AE%89%E5%8D%93%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h3 id="项目练习"><a href="#项目练习" class="headerlink" title="项目练习"></a>项目练习</h3><p><a href="https://blog.csdn.net/qq_42257666/article/details/117952517"></a></p><h6 id="项目1-通讯录"><a href="#项目1-通讯录" class="headerlink" title="项目1 通讯录"></a>项目1 通讯录</h6><ol><li>在activity.xml写好布局</li><li>创建4个Actiivity，写好布局</li><li>查找按钮，按钮设置监听，重写点击方法，新建intent，startActivity</li><li>新建MyHelper.java 写入数据库相关语句</li><li>在对应的界面，实例化myHelper，设置监听，进行数据库数据库。</li></ol><p>TIPS：</p><ul><li>布局design完毕 点一下魔术棒</li><li>Toast没有显示，模拟器wipe data</li><li>布局文件design无法加载 查看发现是插件不匹配，在C盘找到相应文件，删除</li></ul><h6 id="项目2-记事本"><a href="#项目2-记事本" class="headerlink" title="项目2 记事本"></a>项目2 记事本</h6><p>记事本有很多条目，布局相同，内容属性相同</p><ol><li><p>创建记事本列表界面Item</p></li><li><p>封装记录信息实体类NotepadBean</p></li><li><p>编写记事本列表适配器NotepadAdapter，使用ListView展示</p><ul><li>创建NotepadAdapter类</li><li>创建ViewHolder类</li></ul><p>listview里面放置adapter,adapter里面放置item</p></li><li><p>创建数据库</p></li><li></li></ol><h6 id=""><a href="#" class="headerlink" title=""></a></h6><h3 id="毕设"><a href="#毕设" class="headerlink" title="毕设"></a>毕设</h3><h4 id="必备睡眠相关知识"><a href="#必备睡眠相关知识" class="headerlink" title="必备睡眠相关知识"></a>必备睡眠相关知识</h4><ul><li><p>PER蛋白阻断了“周期基因”的活性，并认为通过抑制反馈回路，PER蛋白可以阻止其自身的合成，从而已连续的循环节律调节自身的蛋白水平。</p></li><li><p>人类的生物钟系统是怎样的？</p></li></ul><p>一个能够产生生理性昼夜节律活动的生物钟系统，包括以下三部分：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gcode">光感受器——&gt;时钟——&gt;输出通路<br>视网膜——&gt;节细胞视交叉上核<span class="hljs-comment">(SCN)</span>——&gt;下丘脑<br></code></pre></td></tr></table></figure><ul><li><p>人体中枢生物钟系统</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-operator">•</span> <span class="hljs-type">SCN</span>——视交叉上核；<br><span class="hljs-operator">•</span> <span class="hljs-type">Kidney</span>——肾脏；<br><span class="hljs-operator">•</span> <span class="hljs-type">ACTH</span>——促肾上腺皮质激素；<br><span class="hljs-operator">•</span> <span class="hljs-type">Adrenal</span>——肾上腺<br><span class="hljs-operator">•</span> <span class="hljs-type">Cort</span>——皮质醇<br><span class="hljs-operator">•</span> <span class="hljs-type">HPA</span> axis——下丘脑<span class="hljs-operator">-</span>垂体<span class="hljs-operator">-</span>肾上腺轴<br><span class="hljs-operator">•</span> <span class="hljs-type">PIT</span>——垂体<br><span class="hljs-operator">•</span> 松果体有节奏地产生褪黑激素，它调节睡眠<span class="hljs-operator">/</span>觉醒周期（黄色）<span class="hljs-operator">。</span><br><span class="hljs-operator">•</span> 垂体（<span class="hljs-type">PIT）释放ACTH（绿色）会控制肾上腺（adrenal）有节奏地产生皮质醇（Cort），形成HPA轴</span><span class="hljs-operator">。</span><br><span class="hljs-operator">•</span> 皮质醇充当外周器官的同步器和<span class="hljs-type">SCN节律性的稳定剂</span><span class="hljs-operator">。</span><br></code></pre></td></tr></table></figure></li><li><p>节律调节系统最重要的核心是光照，运用好光照来进行节律的调节是最重要的</p></li><li><p>睡眠压力（Sleep Pressure）也是决定个体白天灵敏性及夜晚睡眠状态的因素之一，是化学物质腺苷，又称嗜睡化学物质在大脑中的积聚，其积聚越多，个体越困倦。</p></li><li><p>去甲肾上腺素同时有神经递质和荷尔蒙的身份，它是有名的“压力”荷尔蒙，同时也是“打或跑”决断中起主要作用的物质。去甲肾上腺素有助清醒。</p></li><li><p>睡眠-觉醒循环</p></li><li><p>睡眠的定义与阶段划分</p></li></ul><p>Non-Rapid Eye Movement（NREM），Rapid Eye Movement（REM）</p><ul><li><strong>多导睡眠监测(Polysomnography)</strong></li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">Poly</span> <span class="hljs-operator">=</span> refers to recording of many different parameters<br><span class="hljs-attribute">Somno</span> <span class="hljs-operator">=</span> relating to sleep<br><span class="hljs-attribute">Graphy</span> <span class="hljs-operator">=</span> charting of recording parameters.<br></code></pre></td></tr></table></figure><p><strong>PSG****采集系统组成</strong></p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">体表 电极 采集盒 放大器 计算机 显示器<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">PSG同时监测下列多个生理信号:<br>Brain <span class="hljs-type">wave</span> <span class="hljs-variable">activity</span> <span class="hljs-operator">=</span> electroencephalogram (EEG) 脑电图<br><span class="hljs-type">Eye</span> <span class="hljs-variable">movements</span> <span class="hljs-operator">=</span> electro-oculogram (EOG) 眼电图<br><span class="hljs-type">Muscle</span> <span class="hljs-variable">activity</span> <span class="hljs-operator">=</span> electromyogram (EMG) including: 肌电图<br>Chin <span class="hljs-title function_">muscle</span> <span class="hljs-params">(submentalis)</span> activity 呼吸气流<br>Leg muscle activity <br>Arm muscle <span class="hljs-title function_">activity</span> <span class="hljs-params">(in certain circumstances)</span> <br>Airflow 血氧饱和度<br>Respiratory activity of chest and abdomen <br>Heart rate <span class="hljs-type">and</span> <span class="hljs-variable">rhythm</span> <span class="hljs-operator">=</span> electrocardiogram (EKG or ECG) 胸腹呼吸活动<br>Oxygen saturation=pulse <span class="hljs-title function_">oximetry</span> <span class="hljs-params">(SaO2)</span> 心电图<br><span class="hljs-type">Carbon</span> <span class="hljs-variable">dioxide</span> <span class="hljs-operator">=</span> end-tidal or transcutaneous CO2 呼末或经皮CO2<br></code></pre></td></tr></table></figure><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs gcode">睡眠呼吸监测装置分级<span class="hljs-comment">(AASM)</span><br>I级，标准多导睡眠监测仪<br><span class="hljs-comment">(Standard polysomnography)</span><br>II级，全指标便携式多导睡眠监测仪<br><span class="hljs-comment">(Comprehensive portable polysomnography)</span><br>II级，改良便携式睡眠呼吸暂停检查<br><span class="hljs-comment">(Modified portable sleep apnea testing)</span><br>IV级，单或双生物指标持续记录<br><span class="hljs-comment">(Continuous single or dual bioparameters)</span><br></code></pre></td></tr></table></figure><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">睡眠时序图<br>• 睡眠总时间：<span class="hljs-keyword">TST</span><br>• 睡眠效率：<span class="hljs-keyword">TST</span>/熄灯到开灯时间<br>• N1，N2，SWS，REM阶段占比：/<span class="hljs-keyword">TST</span><br>• 睡眠延迟：SOL，熄灯到入睡<br>• 睡眠后清醒时间：WASO<br>• REM延迟：REML<br></code></pre></td></tr></table></figure><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs markdown">有哪些睡眠特征（频率）：<br><span class="hljs-bullet">1.</span> β 大于13Hz、<br><span class="hljs-bullet">2.</span> α 8-13Hz、<br><span class="hljs-bullet">3.</span> θ 4-7.9Hz、<br><span class="hljs-bullet">4.</span> δ 0.5-3.9Hz（慢波睡眠中δ 频率通常在0.5-2Hz）<br><br>• 有哪些睡眠特征（波形事件）：<br><span class="hljs-bullet">2.</span> 慢波（N3）、K复合波（N2）、纺锤波（N2 or N3）、锯齿波（REM）<br><span class="hljs-bullet">3.</span> 快速眼动（REM）、慢眼动（W、N1）<br><span class="hljs-bullet">4.</span> 肌电活动幅度（REM＜N3＜N2＜N1=W）<br><span class="hljs-bullet">5.</span> 大体动（没醒）、微觉醒（小于15秒的短醒）<br></code></pre></td></tr></table></figure><p><a href="https://imgse.com/i/piyifSI"><img src="https://z1.ax1x.com/2023/12/03/piyifSI.png" alt="piyifSI.png"></a></p><ul><li>非快速眼动睡眠N2阶段的标志；学习记忆等多种认知功能密切相关；</li><li>纺锤波活动的异常与精神分裂等众多精神类疾病的发病有关。</li><li>纺锤波检测</li><li>摇摆刺激可以<strong>缩短入睡时间</strong>和<strong>加强深度睡眠</strong></li></ul><h4 id="毕设需求分析"><a href="#毕设需求分析" class="headerlink" title="毕设需求分析"></a>毕设需求分析</h4><p>以前的要求：</p><p>app通过蓝牙连接能控制硬件设备在准备入睡的时候开始采集数据，硬件设备采集的数据存储sd卡中。<br>早上某个时间自动或者通过app操作手动的把数据上传到云端。云端有算法，能对数据进行分析，然后把一部分结果返回到app上显示。</p><p>如果有的文章是从app直接传数据到云端我们也是需要的。因为一些睡眠相关的量表等主观信息也是需要从app直接传到云端的。app通过蓝牙控制设备这部分论文里应该会提到。<br>如果没提到我们自己的设备是有这个功能的。后面把设备寄给你，程序拷给你。至于数据从硬件的SD卡里具体如何传输到云端，可能你要看一下论文里有没有，或者按这个需求自己查一下资料</p><h5 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h5><ul><li><p><input disabled="" type="checkbox"> 通过蓝牙连接能控制硬件设备，采集数据</p></li><li><p><input disabled="" type="checkbox"> app操作手动的把数据上传到云端</p></li><li><p><input disabled="" type="checkbox"> 数据分析结果返回到app上显示</p></li><li><p><input disabled="" type="checkbox"> app直接传数据到云端 or 数据从硬件的SD卡里具体如何传输到云端</p></li><li><p><input disabled="" type="checkbox"> 睡眠实时监测</p></li><li><p><input disabled="" type="checkbox"> 历史查询</p></li><li><p><input disabled="" type="checkbox"> 个人中心</p></li><li><p><input disabled="" type="checkbox"> 睡眠评分模块</p></li><li><p><input disabled="" type="checkbox"> 睡眠建议及睡眠历史记录模块</p></li><li><p><input disabled="" type="checkbox"> 睡眠知识与个人设置模块</p></li><li><p><input disabled="" type="checkbox"> 环境及生理参数模块与个人设置模块</p></li></ul><h5 id="大致流程："><a href="#大致流程：" class="headerlink" title="大致流程："></a>大致流程：</h5><p>整个软件的开发，需求分析确定功能，确定接口，确定数据库，确定后端语言和相应代码，确定安卓端的框架，采用哪些组件，大致目录。然后写安卓端的具体代码，先写数据类，接口类，网络类。大致跑通测试下，接着具体开发每页的功能。将后端和数据库部署云。</p><p>安卓端：</p><p>MVVM框架，主页登录，跳转4个fragment</p><img src="D:\pic\typora_pic\image-20240717101536878.png" alt="image-20240717101536878" style="zoom:50%;" /><h6 id="数据类："><a href="#数据类：" class="headerlink" title="数据类："></a>数据类：</h6><p>PUT POST方法</p><p>@Path @Body @Query</p><p><code>@Query</code> 更适合用于<strong>过滤、排序或条件查询</strong></p><p>返回数据的封装差异</p><ul><li><code>MonthlyIndicatorsResponse</code> 和 <code>IndicatorHistoryResponse</code> 是具体的数据类型，通常代表用户的睡眠指标数据。</li><li><code>Response&lt;T&gt;</code> 是对HTTP请求的完整封装，可以获取更多的响应信息（如状态码）。</li><li><code>Call&lt;T&gt;</code> 则是对Retrofit请求的封装，用于在同步或异步情况下执行请求</li></ul><h6 id="today"><a href="#today" class="headerlink" title="today"></a>today</h6><p>CustomClockView.kt 自定义组件</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> viewScope = CoroutineScope(Dispatchers.Main + Job())<br><span class="hljs-comment">//Dispatchers.Main + Job() 创建了一个新的协程作用域，该作用域在主线程上运行，并且拥有自己的作业管理。所有在这个作用域内启动的协程都将与这个作业关联，当作业被取消时，这些协程也会被取消。</span><br></code></pre></td></tr></table></figure><h6 id="clock"><a href="#clock" class="headerlink" title="clock"></a>clock</h6><p>SleepConsistencyView.kt 自定义组件</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">val avgSleepStartTop = (height * (averageSleepStartTime.<span class="hljs-built_in">get</span>(Calendar.HOUR_OF_DAY) + averageSleepStartTime.<span class="hljs-built_in">get</span>(Calendar.MINUTE) / 60f)) / 24<br>        val avgSleepEndTop = (height * (averageSleepEndTime.<span class="hljs-built_in">get</span>(Calendar.HOUR_OF_DAY) + averageSleepEndTime.<span class="hljs-built_in">get</span>(Calendar.MINUTE) / 60f)) / 24<br><br></code></pre></td></tr></table></figure><p>当处理大量数据的列表或可回收视图（如<code>RecyclerView</code>）时，使用<code>ViewHolder</code>可以提高性能。</p><p>当需要在配置更改（如屏幕旋转）时保存数据状态时，ViewModel 非常有用。</p><p>当<code>ViewModel</code>的构造函数需要传入参数时，通常需要使用<code>ViewModelFactory</code>。</p><p>tips:</p><ul><li>使用sharedPreferences在页面间传递UserID</li><li>网络请求使用的Retrofit</li><li>注意UI阻塞，网络请求堵塞，所有耗时操作都使用异步操作，协程，挂起函数。</li><li>使用和风天气api接口</li><li>在Adapter里面使用Jetpack的LiveData进行数据管理</li><li>使用自定义View</li></ul><h5 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h5><p>使用平均时间戳计算平均时间的纵坐标位置有问题，应该从平均时间戳直接转化为年月日时间，从中提取小时、分钟和秒后，最后映射到纵坐标上</p><ul><li>ThreadLocal</li></ul><p>总的来说，ThreadLocal 适用于每个线程需要自己独立的实例且该实例需要在多个方法中被使用，也即变量在线程间隔离而在方法或类间共享的场景。<br>ThreadLocal和Synchonized都用于解决多线程并发访问。但是ThreadLocal与synchronized有本质的区别：<br>1、Synchronized用于线程间的数据共享，而ThreadLocal则用于线程间的数据隔离。<br>2、Synchronized是利用锁的机制，使变量或代码块在某一时该只能被一个线程访问。而ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某一时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享。而Synchronized却正好相反，它用于在多个线程间通信时能够获得数据共享。</p><ul><li><p>协程 lifecycleScope</p></li><li><p><code>onDestroyView()</code>: 当 Fragment 的视图层次结构（View hierarchy）被销毁时调用。这通常发生在 Fragment 被移除或替换时，但 Fragment 本身并未被销毁。例如，当一个 Fragment 被添加到回退栈并随后恢复时，<code>onDestroyView()</code> 会被调用，但 <code>onDestroy()</code> 不会。</p><p><code>onDestroy()</code>: 当 Fragment 本身被销毁时调用。此方法是 Fragment 生命周期的最后一步。在这一步，所有的资源都应该被清理干净。一般在 Fragment 不会再使用时调用。</p><p>在 <code>onPause()</code> 中取消正在进行的请求，可以确保在用户离开当前 Fragment 时停止不必要的网络操作，以提高应用性能和用户体验。</p></li><li><p>RetrofitClient和OkHttp</p></li></ul><p>网络请求的工作本质上是 OkHttp 完成，而 Retrofit 仅负责网络请求接口的封装。</p><p>修改数据类</p><p>1、修改数据库</p><p>2、修改接口</p><p>3、修改后端代码</p><p>4、修改安卓数据类</p><p>5、修改安卓涉及的代码</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>吉他</title>
    <link href="/2023/12/18/%E5%90%89%E4%BB%96/"/>
    <url>/2023/12/18/%E5%90%89%E4%BB%96/</url>
    
    <content type="html"><![CDATA[<h5 id="简谱"><a href="#简谱" class="headerlink" title="简谱"></a>简谱</h5><p>do re mi fa so la si</p><p>音符：1—（全），1-(二分），1(四分)，1下面1条线(八分)，1下面2条线(十六分)</p><p>增时线，</p><p>附点：1&#96;(单),1&#96;&#96;(双)，<strong>只能用于小于4分音符往下</strong>。</p><p>休止符：0000,00,0,<strong>不能用于增时线</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>外语入门学习</title>
    <link href="/2023/12/08/%E5%A4%96%E8%AF%AD%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/12/08/%E5%A4%96%E8%AF%AD%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h4 id="法语"><a href="#法语" class="headerlink" title="法语"></a>法语</h4><h5 id="介绍："><a href="#介绍：" class="headerlink" title="介绍："></a>介绍：</h5><p>印欧语罗曼语族 世界第5大语言</p><p>法语字母表：</p><p><a href="https://imgse.com/i/pi2uU5n"><img src="https://z1.ax1x.com/2023/12/08/pi2uU5n.png" alt="pi2uU5n.png"></a></p><ul><li>音素是最小的语音单位</li><li>法语共有36个音素，16个元音音素，17个辅音音素</li><li>法语的元音字母：AEIOUY</li><li>音标：salut [saly] merci[mεrsi]</li></ul><h4 id="韩语"><a href="#韩语" class="headerlink" title="韩语"></a>韩语</h4><p> 表音文字<br>19个辅音+21个元音<br>辅音：松音 紧音 送气音 无归属<br>ㄱㄷㅂㅅㅊ</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>深度学习</title>
    <link href="/2023/11/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/11/30/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h4 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h4><p><strong>监督学习</strong></p><p>包括决策树、<a href="https://www.zhihu.com/search?q=%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%223148635456%22%7D">朴素贝叶斯</a>、SVM、<a href="https://www.zhihu.com/search?q=k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%223148635456%22%7D">k近邻算法</a>、AdaBoost；回归算法：线性回归，<a href="https://www.zhihu.com/search?q=%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%223148635456%22%7D">逻辑回归</a></p><p><strong>非监督学习</strong></p><p><a href="https://www.zhihu.com/search?q=%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%223148635456%22%7D">聚类算法</a>，比如 K-Means、<a href="https://www.zhihu.com/search?q=%E6%9C%80%E5%A4%A7%E6%9C%9F%E6%9C%9B%E7%AE%97%E6%B3%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22:%22answer%22,%22sourceId%22:%223148635456%22%7D">最大期望算法</a> EM</p><p><strong>半监督学习</strong></p><p><strong>强化学习</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Springboot速成</title>
    <link href="/2023/11/30/Springboot%E9%80%9F%E6%88%90/"/>
    <url>/2023/11/30/Springboot%E9%80%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h3 id="JAVA速成"><a href="#JAVA速成" class="headerlink" title="JAVA速成"></a>JAVA速成</h3><p><a href="https://blog.csdn.net/qq_43546721/article/details/131550605">https://blog.csdn.net/qq_43546721/article/details/131550605</a></p><h5 id="阶段一-Java基础加提升"><a href="#阶段一-Java基础加提升" class="headerlink" title="阶段一:Java基础加提升"></a>阶段一:Java基础加提升</h5><p>1、Java入门<br>2、基础必知<br>3、流程控制<br>4、面向对象</p><ul><li>类与对象</li><li>构造方法重写</li><li>static、super</li><li>封装、继承、多态</li><li>抽象类、接口</li></ul><p>5、异常处理<br>6、集合框架</p><ul><li>ArrayList、LinkedList</li><li>HashSet、TreeSet</li><li>HashMap、TreeMap</li><li>掌握泛型的应用</li></ul><p>7、常用类</p><ul><li>Object、String</li><li>StringBuilder</li><li>System</li><li>Date、DateFormat</li><li>BigDecimal</li><li>Scanner、Random</li></ul><p>8、<strong>多线程</strong></p><ul><li>进程与线程的关系</li><li>Thread、Runnable</li><li>线程安全、线程同步</li><li>线程状态转换</li><li>线程的生命周期</li><li>线程让步、线程锁、线程池</li></ul><p>9、IO流</p><h5 id="阶段二-JavaWeb阶段"><a href="#阶段二-JavaWeb阶段" class="headerlink" title="阶段二:JavaWeb阶段"></a>阶段二:JavaWeb阶段</h5><p>1、前端基础<br>2、数据库基础<br>3、JDBC<br>4、<strong>Maven</strong><br>5、<strong>MyBatis</strong><br>6、XML<br>7、Tomcat服务器<br>8、Servlet</p><ul><li>Servlet的生命周期</li><li>Servlet常用类和接口</li><li>Servlet体系结构</li><li>urlPattern配置和XML配置</li><li>JSP的概念和动作指令</li></ul><p>9、JSP</p><ul><li>JSP的概念和动作指令</li><li>JSP原理</li><li>JSP九大内置对象<ul><li>request、response、session、application、out、pagecontext、config、page、exception</li></ul></li><li>JSP四大域对象</li><li>增删改查分页操作</li><li>文件上传下载监听器和过滤器</li><li>Cookie和Session</li></ul><p>10、AJAX</p><ul><li>了解AJAX JSON</li><li>xmlHttpRequest对象</li><li>jQuery和Ajax</li></ul><h5 id="阶段三-Spring全家桶"><a href="#阶段三-Spring全家桶" class="headerlink" title="阶段三:Spring全家桶"></a>阶段三:Spring全家桶</h5><p>1、Spring</p><ul><li>spring历史及架构体系</li><li>IOC、DI配置</li><li>装配bean(三种方式)</li><li>作用域和生命周期</li><li>注解开发、元注解</li><li>动态代理机制</li><li>aop xml与注解方式</li><li>AspectJ6种通知</li><li>JdbcTemplate</li></ul><p>2、SpringMVC</p><ul><li>SpringMVC简介原理</li><li>SpringMVC入门程序</li><li>处理器映射器、适配器</li><li>注解开发RequestMapping详解</li><li>基础数据类型</li><li>对象、数组、集合</li><li>参数传递</li><li>包装对象、乱码解决</li><li>CRUD案例转发和重定向</li><li>了解Restfull风格</li><li>SpringMVC国际化</li></ul><p>3、MyBaits</p><ul><li>MyBatis开发方式</li><li>Mapper.xml常用配置</li><li>单表查询</li><li>parmterType和resultType</li><li>多表关联查询</li><li>MyBatis逆向工程</li><li>MyBatis缓存</li><li>MyBatis动态SQL</li></ul><p>4、SpringBoot</p><ul><li>SpringBoot概述和入门</li><li>SpringBoot容器功能</li><li>SpringBoot日志</li><li>数据响应与内容协商</li><li>视图解析与模板引擎</li><li>各种框架整合</li></ul><h5 id="阶段四-分布式微服务架构"><a href="#阶段四-分布式微服务架构" class="headerlink" title="阶段四:分布式微服务架构"></a>阶段四:分布式微服务架构</h5><p>1、微服务架构：学习微服务的概念、原则和优势，了解如何将应用程序拆分成小型、自治的服务。</p><p>2、服务注册与发现：学习使用服务注册与发现工具（如Eureka、Consul）管理微服务的注册、发现和负载均衡。</p><p>3、服务通信：学习使用轻量级的通信协议（如REST、gRPC）实现微服务之间的通信，了解消息队列和事件驱动架构。</p><p>4、容器化和编排：学习使用Docker等容器技术打包和部署微服务，使用Kubernetes等容器编排工具管理容器化应用程序。</p><p>5、分布式数据管理：学习处理分布式数据存储和一致性问题，了解数据库拆分、分布式缓存和分布式事务的解决方案。</p><h5 id="阶段五：技能深入提升"><a href="#阶段五：技能深入提升" class="headerlink" title="阶段五：技能深入提升"></a>阶段五：技能深入提升</h5><p>1、多线程和并发编程：学习使用Java并发包（如java.util.concurrent）处理多线程编程，了解线程池、锁机制和并发集合等。</p><p>2、性能优化：学习分析和调优Java应用程序的性能，了解内存管理、垃圾回收、性能监测和调优工具。</p><p>3、反射和字节码操作：学习使用Java的反射机制和字节码操作库，实现动态代理、代码生成和运行时修改类的功能。</p><p>4、函数式编程：学习Java 8及更高版本引入的函数式编程特性，如Lambda表达式和Stream API，提升代码简洁性和可读性。</p><p>5、设计模式：学习常见的设计模式，如单例模式、工厂模式、观察者模式等，了解如何应用设计模式解决常见的软件设计问题。</p><h5 id="阶段六：企业级项目实战"><a href="#阶段六：企业级项目实战" class="headerlink" title="阶段六：企业级项目实战"></a>阶段六：企业级项目实战</h5><p>1、需求分析和项目规划：与团队合作，了解项目需求，并制定项目计划和开发进度。</p><p>2、架构设计和技术选型：根据项目需求，设计系统架构，选择合适的技术栈和开发工具。</p><p>3、开发和测试：根据项目计划，进行系统开发和单元测试，确保代码的质量和功能的正确性。</p><p>4、集成和部署：将各个模块进行集成，进行系统测试，然后部署到生产环境。</p><p>5、运维和维护：监控系统的运行状态，及时处理故障和问题，并进行系统维护和升级。</p><h3 id="Spring速成"><a href="#Spring速成" class="headerlink" title="Spring速成"></a>Spring速成</h3><h5 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h5><ul><li>开源免费框架</li><li>轻量级、非入侵式</li><li>控制反转IOC 面向切片编程AOP</li><li>支持事物的处理和框架整合</li></ul><h5 id="ioc本质"><a href="#ioc本质" class="headerlink" title="ioc本质"></a>ioc本质</h5><p>控制反转是一种通过描述（XML或注解）并通过第三方去生产获取特定对象的方式，在spring中实现控制反转的是ioc容器，其实现方法是依赖注入（DI）。</p><h5 id="Springhello案例"><a href="#Springhello案例" class="headerlink" title="Springhello案例"></a>Springhello案例</h5><p>控制：谁来控制对象的创建，传统应用程序的对象是由程序本身，使用Spring后，由Spring来创建。</p><p>反转：程序本身不创建对象，而变成被动的接收对象。</p><p>依赖注入：利用set方法进行注入</p><p>IOC是一种编程思想，由主动的编程变成被动的接收。</p><p>可以通过newClsaaPathXmlApplicationContext去浏览底层代码。</p><p>到现在，实现不同操作，我们只用在xml配置文件中进行修改了。</p><h5 id="IOC创建对象方式"><a href="#IOC创建对象方式" class="headerlink" title="IOC创建对象方式"></a>IOC创建对象方式</h5><p>无参构造</p><p>有参构造</p><p>1、下标赋值  2、类型  3、参数名</p><p>总结：在配置文件加载时，容器中管理的对象就已经初始化了。</p><h5 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml">alias 别名<br><br>配置<br>id:bean的唯一标识符，也就是相当于我们学的对象名<br>class:bean对象对应的全限定名：包名+类型<br>name:也是别名，可同时取多个<br><br>import<br>将多个配置文件合并成一个<br></code></pre></td></tr></table></figure><h5 id="DI注入"><a href="#DI注入" class="headerlink" title="DI注入"></a>DI注入</h5><p>构造器注入</p><p>set方式注入</p><ul><li>依赖：bean对象的创建依赖于容器</li><li>注入：bean对象的所有属性，由容器来注入</li></ul><p>拓展方式注入 </p><p>c命名和p命名空间注入</p><p>注意点：不能直接使用，需要导入xml约束</p><h5 id="Bean作用域"><a href="#Bean作用域" class="headerlink" title="Bean作用域"></a>Bean作用域</h5><p>singleton：默认机制</p><p>prototype：每次从容器中get时，都会产生一个新对象</p><p>其余的request、session、application只能在web开发中使用</p><h5 id="Bean的自动装配"><a href="#Bean的自动装配" class="headerlink" title="Bean的自动装配"></a>Bean的自动装配</h5><p>spring</p><p>1、在xml中显示配置</p><p>2、在java中显示配置</p><p>3、隐式的自动装配</p><p>byname:需要保证所有的bean的id唯一，并且这个bean需要和自动注入的属性的set方法的值一致。</p><p>bytype:需要保证所有的bean的class唯一，并且这个bean需要和自动注入的属性的类型的值一致。</p><h5 id="使用注解实现自动装配"><a href="#使用注解实现自动装配" class="headerlink" title="使用注解实现自动装配"></a>使用注解实现自动装配</h5><p>使用须知：</p><p>1、导入约束：context约束</p><p>2、配置注解的支持：context:annotation-config</p><p>@Autowired</p><p>直接在属性上使用即可，也可以在set方式上使用</p><p>可以不用编写Set方法了，前提是这个自动装配的属性在IOC（Spring)容器中存在且符合名字Byname。</p><p>科普：@Nullable字段标记了这个注解，说明这个字段可以为null</p><p>如果@Autowired自动装配的环境比较复杂，自动装配无法通过一个注解@Autowired实现时，可以使用@Qualifier(value&#x3D;”xxx”)去配置@Autowired，指定一个唯一的bean对象注入。</p><p>@Resource</p><p>和@Autowired一样都是用来自动装配的，都可以放在属性字段上</p><p>1、bean</p><p>2、属性如何注入</p><p>3、衍生的注解</p><p>@Component</p><ul><li>dao[@Repository]</li><li>service[@Service]</li><li>controller[Controller]</li></ul><p>4、自动装配</p><p>5、作用域</p><p>@Scope</p><p>6、小结</p><ul><li>xml更加万能，适用于任何场合，维护简单方便</li><li>注解 不是自己类使用不了，维护相对复杂</li></ul><p>一般：xml用来管理bean，注解只负责完成属性的注入</p><h5 id="使用Java的方式配置Spring"><a href="#使用Java的方式配置Spring" class="headerlink" title="使用Java的方式配置Spring"></a>使用Java的方式配置Spring</h5><p>Java </p><p>@Configuration 也会Spring容器托管，注册到容器中，因为他本来就是一个@Component。</p><p>@Component配合@ComponentScan使用，也可以单独使用@Bean进行方法注入</p><h5 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h5><p>SpringAOP的底层[SpringAOP和SpringMVC]</p><p>代理模式的分类：</p><ul><li><p>静态代理</p><p>角色分析：</p><ul><li><p>抽象角色：一般会使用接口或抽象类来解决</p></li><li><p>真实角色：被代理的角色</p></li><li><p>代理角色：代理真实角色，一般会做一些附属操作</p></li><li><p>客户：访问代理对象的人</p><p>在已有功能上增加一个日志输出：新建一个代理类，代理类中调用原方法，增加新功能。</p></li></ul></li><li><p>动态代理</p><ul><li>和静态代理角色一样</li><li>代理类是动态生成的，不是我们写好的</li><li>分为：基于接口的 和 基于类的动态代理<ul><li>基于接口：JDK动态代理</li><li>基于类：cglib</li><li>java字节码实现：javasist</li></ul></li></ul></li></ul><p>需要了解两个类：Proxy，InvocationHandler</p><h5 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h5><p>Aspect Oriented Programming面向切面编程</p><p>注意 动态代理代理的是接口</p><p>实现方式：</p><ul><li><p>方法一：使用Spring的API接口【主要是SpringAPI接口实现】</p></li><li><p>方法二：自定义类实现AOP【主要是切面定义】</p></li><li><p>方法三：使用注解@Aspect</p></li></ul><h5 id="整合Mybatis"><a href="#整合Mybatis" class="headerlink" title="整合Mybatis"></a>整合Mybatis</h5><p>步骤：</p><p>1、导入相关jar包</p><ul><li>junit</li><li>mybatis</li><li>mysql</li><li>spring相关的</li><li>aop</li><li>mybatis-spring</li></ul><p>2、编写配置文件</p><p>3、测试</p><h5 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h5><p>1、回顾事务</p><p>把一组业务当初一个业务来做：要么都成功，要么都失败。</p><p>事务ACID原则</p><ul><li>原子性</li><li>一致性</li><li>隔离性<ul><li>多个业务可能操作一个资源，防止数据损坏</li></ul></li><li>持久性<ul><li>事务一旦提交，无论发生什么</li></ul></li></ul><p>比如 先插入再删除，但删除代码有问题。执行时就不能插入成功，而应该作为整体，操作失败。</p><ul><li>声明式业务：AOP</li><li>编程式业务</li></ul><h4 id="Springboot速成"><a href="#Springboot速成" class="headerlink" title="Springboot速成"></a>Springboot速成</h4><ul><li>创建Maven项目</li><li>导入SpringBoot起步依赖</li><li>定义Controller</li><li>编写引导类：SpringBoot项目的入口</li><li>测试</li></ul><p>配置：properties&gt;yml&gt;yaml</p><p>yaml基本语法：</p><ul><li>大小写敏感</li><li>数据值前面必须有空格，作为分隔符</li><li>缩进表示层级关系</li><li>#表示注释</li></ul><p>数据格式</p><ul><li>对象（map）：键值对的集合</li><li>数组：一组按次序排列的值</li><li>纯量：单个的、不可分的值</li></ul><h5 id="读取配置内容"><a href="#读取配置内容" class="headerlink" title="读取配置内容"></a>读取配置内容</h5><ul><li>@Value 一个个注入</li><li>Environment</li><li>@ConfigurationProperties</li></ul><h5 id="profile"><a href="#profile" class="headerlink" title="profile"></a>profile</h5><p>动态配置切换</p><p>配置方式</p><ul><li>多profile文件方式<ul><li>application-dev.properties&#x2F;yml 开发环境</li><li>application-test.properties&#x2F;yml 测试环境</li><li>application-pro.properties&#x2F;yml 生产环境</li></ul></li><li>yml多文档方式<ul><li>使用—分割不同配置</li></ul></li></ul><p>激活方式</p><ul><li>配置文件：在配置文件中配置：spring.profile.active&#x3D;dev</li><li>虚拟机参数:在VM options指定：-Dspiring.profile.active&#x3D;dev</li><li>命令行参数：java-jar xxx.jar –spring.profiles.active&#x3D;dev</li></ul><p>内部配置加载顺序</p><ul><li>file:.&#x2F;config&#x2F;</li><li>file:.&#x2F;</li><li>classpath:&#x2F;config&#x2F;</li><li>classpath:&#x2F;</li></ul><p>外部配置加载顺序</p><h5 id="整合其他框架"><a href="#整合其他框架" class="headerlink" title="整合其他框架"></a>整合其他框架</h5><ul><li><p>Junit  单元测试框架</p></li><li><p>搭建SpringBoot工程</p><ul><li>引入start-test起步依赖</li></ul></li><li><p>编写测试类</p><ul><li><p>添加测试相关注解</p><ul><li>@RunWith(SpringRunner.class)</li></ul></li><li><p>@SpringBootTest(classes&#x3D;启动类.class)</p></li><li><p>编写测试方法</p></li></ul></li><li><p>Redis  <em>key-value 存储系统，是跨平台的非关系型数据库。</em></p><ul><li>搭建SpringBoot工程</li><li>引入redis起步依赖</li><li>配置redis相关属性</li><li>注入RedisTemplate模板</li><li>编写测试方法，测试</li></ul></li><li><p>mybaits  一个持久层框架，完成的是对数据库的访问和操作</p><ul><li>搭建SpringBoot工程 </li><li>引入mybaits起步依赖，添加mysql驱动</li><li>配置redis相关属性 </li><li>注入RedisTemplate模板 </li><li>编写测试方法，测试</li></ul></li></ul><h5 id="高级内容"><a href="#高级内容" class="headerlink" title="高级内容"></a>高级内容</h5><ul><li>原理分析</li><li>监控</li><li>项目部署</li></ul><h5 id="SpringBoot-Web开发"><a href="#SpringBoot-Web开发" class="headerlink" title="SpringBoot Web开发"></a>SpringBoot Web开发</h5><p>要解决的问题：</p><ul><li>导入静态资源</li><li>首页</li><li>jsp,模板引擎Thymelesf</li><li>装配扩展SpringMVC</li><li>增删改查</li><li>拦截器</li><li>国际化</li></ul><h5 id="shiro"><a href="#shiro" class="headerlink" title="shiro"></a>shiro</h5><p>安全权限框架</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端项目</title>
    <link href="/2023/11/24/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/"/>
    <url>/2023/11/24/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="考察目标"><a href="#考察目标" class="headerlink" title="考察目标"></a>考察目标</h1><ol><li>webpack的使用以及配置文件编写</li><li>react的使用</li><li>理解模块化，并且操作三方模块的引入</li><li>ES6语法基础</li><li>npm基础使用</li><li>Node.js的基础使用</li></ol><h1 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h1><ul><li>前端：用react+typescript实现一个todo应用。并且将静态资源(html,js,css等)编译到node.js的静态资源目录中。端口：3000 </li><li>后端：使用node.js+javascript 将数据存储到服务端json文件中。端口3001</li><li>其它要求：两个项目的根目录下，要有READMD.md，记录自己的思路和遇到的问题。</li><li>两个项目的package.json，加注释（package.json.md）：说一下每一行的意思</li></ul><h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><ul><li><ul><li><ul><li><p>client目录：前端react项目目录。</p></li><li><ul><li>client&#x2F;src 代码目录</li><li><code>npm run start</code> 开发模式，这个时候启动<a href="http://localhost:3000/index.html">http://localhost:3000/index.html</a> 用于开发，并且使用webpack-dev-server的proxy配置，将  &#x2F;api请求转发到3001。因此ajax请求是相对路径。</li><li><code>npm run build</code>: 编译代码，编译后的代码会存入build目录。（提示：使用koa-static配置静态资源目录为此build目录）</li></ul></li><li><p>server目录：服务端项目目录</p></li><li><ul><li><p>server&#x2F;代码目录</p></li><li><p>server&#x2F;public 静态资源，来自client目录build</p></li><li><p>接口：(create和update也可以合二为一)</p></li><li><ul><li>post &#x2F;api&#x2F;todo&#x2F;create 新建todo</li><li>post &#x2F;api&#x2F;todo&#x2F;update 修改</li><li>get &#x2F;api&#x2F;todo&#x2F;list 获取列表</li><li>post &#x2F;api&#x2F;todo&#x2F;delete 删除</li></ul></li></ul></li></ul></li></ul></li></ul><p>使用方法</p><ol><li>进入server目录，npm run start 启动3001端口，看是否正常</li><li>进入client目录执行npm run start，启动3000，看是否正常</li><li>停掉前端3000端口，进入client目录执行npm run build，看是否有报错.生成&#x2F;dist文件</li><li>打开 <a href="http://localhost:3001/index.html%EF%BC%8C%E4%BD%93%E9%AA%8C%E5%8A%9F%E8%83%BD%EF%BC%8C%E9%AA%8C%E8%AF%81%E4%BD%9C%E4%B8%9A%E5%AE%8C%E6%88%90%E5%BA%A6%E3%80%82">http://localhost:3001/index.html，体验功能，验证作业完成度。</a></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>安卓学习</title>
    <link href="/2023/11/12/%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/11/12/%E5%AE%89%E5%8D%93%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="安卓速成"><a href="#安卓速成" class="headerlink" title="安卓速成"></a>安卓速成</h3><h4 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h4><p>Android其本质就是在标准的Linux系统上增加了Java虚拟机Dalvik，并在Dalvik虚拟机上搭建了一个JAVA的application framework，所有的应用程序都是基于JAVA的application framework之上。</p><h4 id="2-应用程序的架构设计"><a href="#2-应用程序的架构设计" class="headerlink" title="2 应用程序的架构设计"></a>2 应用程序的架构设计</h4><p>简化了组件的重用，隐藏在每个应用后面的是一系列的服务和系统, </p><p>其中包括：</p><ul><li><p>丰富而又可扩展的视图（Views），可以用来构建应用程序， 它包括列表（lists），网格（grids），文本框（text boxes），按钮（buttons）， 甚至可嵌入的web浏览器。</p></li><li><p>内容提供器（Content Providers）使得应用程序可以访问另一个应用程序的数据（如联系人数据库）， 或者共享它们自己的数据。</p></li><li><p>资源管理器（Resource Manager）提供非代码资源的访问，如本地字符串，图形，和布局文件（layout files）。</p></li><li><p>通知管理器（Notification Manager）使得应用程序可以在状态栏中显示自定义的提示信息。</p></li><li><p>活动管理器（Activity Manager）用来管理应用程序生命周期并提供常用的导航回退功能。</p></li></ul><h4 id="3-Android-执行程序"><a href="#3-Android-执行程序" class="headerlink" title="3 Android 执行程序"></a>3 <strong>Android</strong> <strong>执行程序</strong></h4><p>一个APK文件结构为：</p><ul><li><p>META-INF\ （注：Jar文件中常可以看到）；</p></li><li><p>res\ (注：存放资源文件的目录) ；</p></li><li><p>AndroidManifest.xml (注：程序全局配置文件) ；</p></li><li><p>classes.dex （注：Dalvik字节码）；</p></li><li><p>resources.arsc (注：编译后的二进制资源文件)。</p></li></ul><h4 id="4-Android开发的四大组件"><a href="#4-Android开发的四大组件" class="headerlink" title="4 Android开发的四大组件"></a>4 Android开发的四大组件</h4><ul><li>活动（Activity）： 用于表现功能。</li><li>服务（Service）： 后台运行服务，不提供界面呈现。</li><li>广播接收器（BroadcastReceiver）：用于接收广播。</li><li>内容提供商（Content Provider）：支持在多个应用中存储和读取数据，类似数据库。</li></ul><h4 id="5-Gradle"><a href="#5-Gradle" class="headerlink" title="5 Gradle"></a>5 <strong>Gradle</strong></h4><p>Gradle是一个基于Apache Ant和Apache Maven概念的项目自动化构建工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，抛弃了基于XML的各种繁琐配置。</p><p>gradle 作为编译工具，有很多的任务，比如 build、rebuild、clean 等。</p><h4 id="6-AndroidManifest-xml"><a href="#6-AndroidManifest-xml" class="headerlink" title="6 AndroidManifest.xml"></a>6 <strong>AndroidManifest.xml</strong></h4><p>AndroidManifest.xml 是每个android程序中必须的文件，它位于整个项目的根目录。AndroidManifest.xml是Android应用的入口文件，它描述了package中暴露的组件（activities, services, 等等），他们各自的实现类，各种能被处理的数据和启动位置。</p><h4 id="7-Android-模块文件"><a href="#7-Android-模块文件" class="headerlink" title="7 Android 模块文件"></a>7 <strong>Android 模块文件</strong></h4><ul><li><strong>AndroidManifest.xml：</strong> 包含应用程序的配置信息，如权限声明、组件声明等。</li><li><strong>build.gradle：</strong> 包含项目的构建配置，定义了项目的依赖关系、版本信息等。</li><li><strong>res&#x2F; 目录：</strong> 包含应用程序的资源文件，如布局文件、图标、字符串等。</li><li><strong>src&#x2F; 目录：</strong> 包含应用程序的源代码文件，按照主&#x2F;测试代码和各个模块进行组织。</li><li><strong>assets&#x2F; 目录：</strong> 包含应用程序需要在运行时使用的原始文件，如数据库文件、字体文件等。</li></ul><h4 id="8-Android-UI"><a href="#8-Android-UI" class="headerlink" title="8 Android UI"></a>8 <strong>Android UI</strong></h4><h5 id="五大布局"><a href="#五大布局" class="headerlink" title="五大布局"></a>五大布局</h5><ul><li>线性布局(LinearLayout)</li><li>框架布局(FrameLayout)</li><li>表格布局(TableLayout)</li><li>相对布局(RelativeLayout)</li><li>网格布局(GridLayout)</li></ul><h5 id="常用的组件"><a href="#常用的组件" class="headerlink" title="常用的组件"></a>常用的组件</h5><ul><li>TextView(文本框)</li><li>EditText(输入框)</li><li>Button(按钮)</li><li>ImageButton(图像按钮)</li><li>ImageView(图像视图)</li><li>RadioButton(单选按钮)&amp;Checkbox(复选框)</li><li>开关按钮ToggleButton和开关Switch</li><li>ProgressBar(进度条)</li><li>SeekBar(拖动条)</li><li>RatingBar(星级评分条)</li><li>ScrollView(滚动条)</li><li>Date &amp; Time组件等</li></ul><h5 id="Adapter-类"><a href="#Adapter-类" class="headerlink" title="Adapter 类"></a>Adapter 类</h5><p>Adapter是用来帮助填充数据的中间桥梁，简单点说就是：将各种数据以合适的形式显示到view上,提供给用户看。</p><p><a href="https://z1.ax1x.com/2023/11/14/piYP3hd.png"></a></p><p>关系图解析：</p><p>Model：通常可以理解为数据,负责执行程序的核心运算与判断逻辑,通过 view 获得用户输入的数据,然后根据从数据库查询相关的信息,最后进行运算和判断,再将得到的结果交给 view 来显示。<br>view:用户的操作接口,说白了就是 GUI,应该使用哪种接口组件,组件间的排列位置与顺序都需要设计。<br>Controller:控制器,作为model与view之间的枢纽,负责控制程序的执行流程以及对象之间的一个互动。</p><h6 id="ArrayAdapter使用示例"><a href="#ArrayAdapter使用示例" class="headerlink" title="ArrayAdapter使用示例"></a>ArrayAdapter使用示例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span>&#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreat</span><span class="hljs-params">(Bundle savedInstanceState)</span>&#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        String[] strs = &#123;<span class="hljs-string">&quot;A&quot;</span>,<span class="hljs-string">&quot;B&quot;</span>,<span class="hljs-string">&quot;C&quot;</span>,<span class="hljs-string">&quot;D&quot;</span>,<span class="hljs-string">&quot;E&quot;</span>&#125;;<br>        ArrayAdapter&lt;String&gt; adapter = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayAdapter</span>&lt;String&gt;(<span class="hljs-built_in">this</span>,R.layout.simple_expandable_list_item_1,strs);<br>        <span class="hljs-type">ListView</span> <span class="hljs-variable">list_test</span> <span class="hljs-operator">=</span> (ListView) findViewByID(R.id.list_test);<br>        R.id.list_test.setAdapter;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="SimpleAdapter使用示例"><a href="#SimpleAdapter使用示例" class="headerlink" title="SimpleAdapter使用示例"></a>SimpleAdapter使用示例</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String[] names = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;B神&quot;</span>, <span class="hljs-string">&quot;基神&quot;</span>, <span class="hljs-string">&quot;曹神&quot;</span>&#125;;<br>    <span class="hljs-keyword">private</span> String[] says = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;无形被黑，最为致命&quot;</span>, <span class="hljs-string">&quot;大神好厉害~&quot;</span>, <span class="hljs-string">&quot;我将带头日狗~&quot;</span>&#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] imgIds = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;R.mipmap.head_icon1, R.mipmap.head_icon2, R.mipmap.head_icon3&#125;;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br><br>        List&lt;Map&lt;String, Object&gt;&gt; listitem = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;Map&lt;String, Object&gt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; names.length; i++) &#123;<br>            Map&lt;String, Object&gt; showitem = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;String, Object&gt;();<br>            showitem.put(<span class="hljs-string">&quot;touxiang&quot;</span>, imgIds[i]);<br>            showitem.put(<span class="hljs-string">&quot;name&quot;</span>, names[i]);<br>            showitem.put(<span class="hljs-string">&quot;says&quot;</span>, says[i]);<br>            listitem.add(showitem);<br>        &#125;<br><br>        <span class="hljs-comment">//创建一个simpleAdapter</span><br>        <span class="hljs-type">SimpleAdapter</span> <span class="hljs-variable">myAdapter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleAdapter</span>(getApplicationContext(), listitem, R.layout.list_item, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;touxiang&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;says&quot;</span>&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;R.id.imgtou, R.id.name, R.id.says&#125;);<br>        <span class="hljs-type">ListView</span> <span class="hljs-variable">listView</span> <span class="hljs-operator">=</span> (ListView) findViewById(R.id.list_test);<br>        listView.setAdapter(myAdapter);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h6 id="ListView简单实用"><a href="#ListView简单实用" class="headerlink" title="ListView简单实用"></a>ListView简单实用</h6><h6 id="BaseAdapter优化"><a href="#BaseAdapter优化" class="headerlink" title="BaseAdapter优化"></a>BaseAdapter优化</h6><p>而这个Adapter则是中间的这个Controller的部分：</p><p>Model(数据) —&gt; Controller(以什么方式显示到)—&gt; View(用户界面) </p><ul><li>BaseAdapter：抽象类，实际开发中继承这个类并且重写相关方法，用得最多的一个Adapter！</li><li>ArrayAdapter：支持泛型操作，最简单的一个 Adapter，只能展现一行文字。</li><li>SimpleAdapter：同样具有良好扩展性的一个 Adapter，可以自定义多种效果！</li><li>SimpleCursorAdapter：用于显示简单文本类型的 listView，一般在数据库那里会用到，不过有点过时， 不推荐使用！</li></ul><p>其实一个BaseAdapter就够玩的了，至于其他的，实际开发中用得不多，后面用到再讲解。 </p><ul><li>ListView</li><li>GridView</li><li>Spinner</li><li>AutoCompleteTextView</li><li>ExpandableListView</li><li>ViewFlipper</li><li>ViewPager</li><li>DrawerLayout 等</li></ul><h6 id="常用的信息提示类的组件"><a href="#常用的信息提示类的组件" class="headerlink" title="常用的信息提示类的组件"></a>常用的信息提示类的组件</h6><ul><li>Toast</li><li>Notification</li><li>AlertDialog</li><li>PopupWindow</li></ul><h5 id="9事件处理机制"><a href="#9事件处理机制" class="headerlink" title="9事件处理机制"></a>9<strong>事件处理机制</strong></h5><p>事件处理机制就是我们和UI发生交互时，我们在背后添加一些小动作而已！</p><h6 id="基于监听的时间处理机制模型"><a href="#基于监听的时间处理机制模型" class="headerlink" title="基于监听的时间处理机制模型"></a><strong>基于监听的时间处理机制模型</strong></h6><ul><li><p><strong>直接用匿名内部类</strong></p></li><li><p><strong>使用内部类</strong> 使用优点:可以在该类中进行复用,可直接访问外部类的所有界面组件！</p></li><li><p>**使用外部类 **这种形式用的比较少！因为外部类不能直接访问</p><p>用户界面 类中的组件,要通过构造方法将组件传入使用;这样导致的结果就是代码不够简洁！</p></li><li><p><strong>直接使用Activity作为事件监听器</strong> 只需要让Activity类实现XxxListener事件监听接口,在Activity中定义重写对应的事件处理器方法</p></li><li><p><strong>直接绑定到标签</strong></p></li></ul><h6 id="基于回调的事件处理机制"><a href="#基于回调的事件处理机制" class="headerlink" title="基于回调的事件处理机制"></a><strong>基于回调的事件处理机制</strong></h6><h6 id="Handler消息传递机"><a href="#Handler消息传递机" class="headerlink" title="Handler消息传递机"></a><strong>Handler消息传递机</strong></h6><p>通过Handler来通知UI组件更新</p><h5 id="10四大组件"><a href="#10四大组件" class="headerlink" title="10四大组件"></a>10四大组件</h5><ul><li>活动（Activity）用于表现功能</li><li>服务（Service）在后台运行，不提供界面呈现</li><li>广播接收器（BroadcastReceiver）用于接收广播</li><li>内容提供商（Content Provider）支持在多个应用中存储和读取数据，类似数据库。</li></ul><h5 id="11Fragment"><a href="#11Fragment" class="headerlink" title="11Fragment"></a>11<strong>Fragment</strong></h5><p>Android运行在各种各样的设备中，有小屏幕的手机，超大屏的平板甚至电视。</p><ul><li>针对屏幕尺寸的差距，Fragment的出现就是为了解决这样的问题。你可以把Fragment当成Activity的一个界面的一个组成部分，甚至Activity的界面可以完全有不同的Fragment组成。</li><li>fragment拥有自己的生命周期和接收、处理用户的事件，这样就不必在Activity写一堆控件的事件处理的代码了。可以动态的添加、替换和移除某个Fragment。</li><li>一个页面可分为多个fragment，按钮点击动态添加fragment。</li><li>事务 实现返回栈addToBackStack()</li><li>Activty和Fragment的相互调用。</li><li>Fragment的状态和回调（异步 回调 多线程）</li><li>动态加载布局</li><li></li></ul><h5 id="12-Android-数据存储"><a href="#12-Android-数据存储" class="headerlink" title="12 Android 数据存储"></a>12 <strong>Android</strong> <strong>数据存储</strong></h5><p>SQLite</p><p>几个相关类：</p><ul><li>SQLiteOpenHelper 抽象类，继承该类，重写数据库创建及更新的方法，通过该类的对象获取数据库实例，或者关闭数据库。</li><li>SQLiteDatabase 数据库访问类，通过该类的对象对数据库做一些增删改查</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDBOpenHelper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SQLiteOpenHelper</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyDBOpenHelper</span><span class="hljs-params">(Context context, String name, CursorFactory factory,</span><br><span class="hljs-params">            <span class="hljs-type">int</span> version)</span> &#123;<span class="hljs-built_in">super</span>(context, <span class="hljs-string">&quot;my.db&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>); &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">//数据库第一次创建时被调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(SQLiteDatabase db)</span> &#123;<br>        db.execSQL(<span class="hljs-string">&quot;CREATE TABLE person(personid INTEGER PRIMARY KEY AUTOINCREMENT,name VARCHAR(20))&quot;</span>);<br>        <br>    &#125;<br>    <span class="hljs-comment">//软件版本号发生改变时调用</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUpgrade</span><span class="hljs-params">(SQLiteDatabase db, <span class="hljs-type">int</span> oldVersion, <span class="hljs-type">int</span> newVersion)</span> &#123;<br>        db.execSQL(<span class="hljs-string">&quot;ALTER TABLE person ADD phone VARCHAR(12) NULL&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用使用Android提供的API操作SQLite</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">View</span>.OnClickListener &#123;<br><br>    <span class="hljs-keyword">private</span> Context mContext;<br>    <span class="hljs-keyword">private</span> Button btn_insert;<br>    <span class="hljs-keyword">private</span> Button btn_query;<br>    <span class="hljs-keyword">private</span> Button btn_update;<br>    <span class="hljs-keyword">private</span> Button btn_delete;<br>    <span class="hljs-keyword">private</span> SQLiteDatabase db;<br>    <span class="hljs-keyword">private</span> MyDBOpenHelper myDBHelper;<br>    <span class="hljs-keyword">private</span> StringBuilder sb;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        mContext = MainActivity.<span class="hljs-built_in">this</span>;<br>        myDBHelper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyDBOpenHelper</span>(mContext, <span class="hljs-string">&quot;my.db&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-number">1</span>);<br>        bindViews();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bindViews</span><span class="hljs-params">()</span> &#123;<br>        btn_insert = (Button) findViewById(R.id.btn_insert);<br>        btn_query = (Button) findViewById(R.id.btn_query);<br>        btn_update = (Button) findViewById(R.id.btn_update);<br>        btn_delete = (Button) findViewById(R.id.btn_delete);<br><br>        btn_query.setOnClickListener(<span class="hljs-built_in">this</span>);<br>        btn_insert.setOnClickListener(<span class="hljs-built_in">this</span>);<br>        btn_update.setOnClickListener(<span class="hljs-built_in">this</span>);<br>        btn_delete.setOnClickListener(<span class="hljs-built_in">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>        db = myDBHelper.getWritableDatabase();<br>        <span class="hljs-keyword">switch</span> (v.getId()) &#123;<br>            <span class="hljs-keyword">case</span> R.id.btn_insert:<br>                <span class="hljs-type">ContentValues</span> <span class="hljs-variable">values1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContentValues</span>();<br>                values1.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;呵呵~&quot;</span> + i);<br>                i++;<br>                <span class="hljs-comment">//参数依次是：表名，强行插入null值得数据列的列名，一行记录的数据</span><br>                db.insert(<span class="hljs-string">&quot;person&quot;</span>, <span class="hljs-literal">null</span>, values1);<br>                Toast.makeText(mContext, <span class="hljs-string">&quot;插入完毕~&quot;</span>, Toast.LENGTH_SHORT).show();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> R.id.btn_query:<br>                sb = <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>                <span class="hljs-comment">//参数依次是:表名，列名，where约束条件，where中占位符提供具体的值，指定group by的列，进一步约束</span><br>                <span class="hljs-comment">//指定查询结果的排序方式</span><br>                <span class="hljs-type">Cursor</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> db.query(<span class="hljs-string">&quot;person&quot;</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>                <span class="hljs-keyword">if</span> (cursor.moveToFirst()) &#123;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">pid</span> <span class="hljs-operator">=</span> cursor.getInt(cursor.getColumnIndex(<span class="hljs-string">&quot;personid&quot;</span>));<br>                        <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> cursor.getString(cursor.getColumnIndex(<span class="hljs-string">&quot;name&quot;</span>));<br>                        sb.append(<span class="hljs-string">&quot;id：&quot;</span> + pid + <span class="hljs-string">&quot;：&quot;</span> + name + <span class="hljs-string">&quot;\n&quot;</span>);<br>                    &#125; <span class="hljs-keyword">while</span> (cursor.moveToNext());<br>                &#125;<br>                cursor.close();<br>                Toast.makeText(mContext, sb.toString(), Toast.LENGTH_SHORT).show();<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> R.id.btn_update:<br>                <span class="hljs-type">ContentValues</span> <span class="hljs-variable">values2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContentValues</span>();<br>                values2.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;嘻嘻~&quot;</span>);<br>                <span class="hljs-comment">//参数依次是表名，修改后的值，where条件，以及约束，如果不指定三四两个参数，会更改所有行</span><br>                db.update(<span class="hljs-string">&quot;person&quot;</span>, values2, <span class="hljs-string">&quot;name = ?&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;呵呵~2&quot;</span>&#125;);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> R.id.btn_delete:<br>                <span class="hljs-comment">//参数依次是表名，以及where条件与约束</span><br>                db.delete(<span class="hljs-string">&quot;person&quot;</span>, <span class="hljs-string">&quot;personid = ?&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;<span class="hljs-string">&quot;3&quot;</span>&#125;);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://www.runoob.com/w3cnote/android-tutorial-sqlite-intro.html">相关代码</a></p><h5 id="13-Android-多媒体编程"><a href="#13-Android-多媒体编程" class="headerlink" title="13 Android 多媒体编程"></a>13 <strong>Android</strong> <strong>多媒体编程</strong></h5><h5 id="14-Android-绘图与动画"><a href="#14-Android-绘图与动画" class="headerlink" title="14 Android****绘图与动画"></a>14 <strong>Android****绘图与动画</strong></h5><h5 id="15-Android-网络编程"><a href="#15-Android-网络编程" class="headerlink" title="15 Android 网络编程"></a>15 <strong>Android</strong> <strong>网络编程</strong></h5><p>有 Http 协议，Json 解析类解析 Json，XML 解析的几种常用方式，HttpUrlConnection 和 HttpClient 的使用，文件的上传，</p><p>下载；WebService 的使用，WebView，Socket 通信的使用等。网络编程一般都需要增加权限</p><uses-permission android:name="android.permission.INTERNET" /><p>网络编程一般都使用第三方的组件，很少使用自带的，</p><h5 id="16-Android-消息处理机制"><a href="#16-Android-消息处理机制" class="headerlink" title="16 Android****消息处理机制"></a>16 <strong>Android****消息处理机制</strong></h5><h5 id="17-杂项开发"><a href="#17-杂项开发" class="headerlink" title="17 杂项开发"></a>17 <strong>杂项开发</strong></h5><p>不知道是不是因为之前导入别人的项目，改了很多设置后，今天运行安卓模拟器跑不起来，</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Cannot reach ADB <span class="hljs-keyword">server</span>, attempting <span class="hljs-keyword">to</span> reconnect.(moments ago)<br><br></code></pre></td></tr></table></figure><p>尝试更换模拟器，查看SDK与API，没有问题，没有解决。</p><p>最终解决：取消勾选 “Enable adb mDNS for wireless debugging”</p><p>具体位置File-Settings-Build, Extension, Deployment-Debugger或者直接搜 adb</p><p>Fragment开发，平板模拟器竖着的。</p><p>解决：平板模拟器内部的屏幕设置问题</p><p><a href="https://blog.csdn.net/Sophorae/article/details/105322700">https://blog.csdn.net/Sophorae/article/details/105322700</a></p><p>kotlin-android-extensions插件也被废弃了</p><p>升级了Android Studio 4.1之后，发现新建项目的时候Android Studio已经不会自动帮我们引入kotlin-android-extensions插件了，需要自己手动去添加才能使用，是不是Google不再推荐使用这个插件了？</p><p>《第一行代码 第3版》的另外一篇DLC：<a href="https://blog.csdn.net/guolin_blog/article/details/113089706">https://blog.csdn.net/guolin_blog/article/details/113089706</a></p><h3 id="kotlin"><a href="#kotlin" class="headerlink" title="kotlin"></a>kotlin</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><h5 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h5><p>关键字只有val和var</p><p><code>lateinit</code> 是一种延迟初始化方式，必须在使用前初始化</p><p><code>lazy</code> 是一种懒加载方式，会在第一次访问时初始化</p><p>不加分号</p><p>变量延迟赋值时，需要显示申明变量类型</p><h5 id="逻辑控制"><a href="#逻辑控制" class="headerlink" title="逻辑控制"></a>逻辑控制</h5><ul><li>if 可以有返回值</li></ul><p>语法糖 函数只有一行代码使用 省略函数体 等号连接在函数尾部。</p><ul><li>when 箭头</li></ul><p>匹配值-&gt;{执行逻辑}</p><p>is 关键字类型匹配</p><ul><li>循环语句for in</li></ul><p>val range&#x3D;0..10 .. 关键字闭区间</p><p>val range&#x3D;0 until 10 左闭右开</p><p>step 跳过元素</p><p>downTo降序</p><h5 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h5><ul><li>类和对象</li></ul><p>类似Java 去掉new关键字</p><ul><li>继承与构造函数</li></ul><p>非抽象类默认不可继承 加上open关键字</p><p>继承：Java使用extends Kotlin使用：</p><p>主构造函数：没有函数体 使用init结构体编写逻辑</p><p>次构造函数：几乎用不到，Kotlin提供了一个给函数设定参数默认值的功能</p><h5 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h5><ul><li><p>多态</p></li><li><p>可见性修饰符：</p></li></ul><p>Java：public\private\protected\default</p><p>Kotlin:public\private\protected\internal</p><h5 id="数据类与单例类"><a href="#数据类与单例类" class="headerlink" title="数据类与单例类"></a>数据类与单例类</h5><p>关键字：data</p><p>单例类：避免创建重复的对象，使用object关键字</p><h5 id="Lambda编程"><a href="#Lambda编程" class="headerlink" title="Lambda编程"></a>Lambda编程</h5><p>集合的创建与遍历：内置listOf()函数 创建的是不可变集合</p><p>mutableListOf()</p><h4 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h4><h4 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h4><h4 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h4><h4 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h4><h4 id="数据存储技术"><a href="#数据存储技术" class="headerlink" title="数据存储技术"></a>数据存储技术</h4><h4 id="跨程序共享数据"><a href="#跨程序共享数据" class="headerlink" title="跨程序共享数据"></a>跨程序共享数据</h4><h4 id="手机多媒体"><a href="#手机多媒体" class="headerlink" title="手机多媒体"></a>手机多媒体</h4><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><p>在后台执行长时间运行操作的组件 不允许子线程进行UI操作，但有时我们必须在子线程进行一些耗时操作，然后根据任务的执行结果更新UI控件 异步消息处理机制。通常，协程足以处理大多数异步任务，尤其是 UI 相关的任务。但有些场景下，<code>Service</code> 和协程可能需要结合使用：前台服务和<strong>绑定服务（Bound Service）</strong>：如果你的应用中有多个组件需要与 <code>Service</code> 交互，并且需要执行后台任务，你可以在 <code>Service</code> 中使用协程来简化异步操作。</p><ul><li>解析异步消息处理机制 Message Handle MessageQueue Looper</li><li>使用AsyncTask</li><li>onBind 唯一的抽象方法</li><li>启动和停止主要是通过Intent实现的</li><li>Activity和Service进行通信 Binder</li><li>前台Service</li><li>多线程 Service的每个方法里面里开启一个子线程  异步的会自动停止的IntentService</li></ul><h4 id="网络技术"><a href="#网络技术" class="headerlink" title="网络技术"></a>网络技术</h4><h4 id="Material-Design"><a href="#Material-Design" class="headerlink" title="Material Design"></a>Material Design</h4><h4 id="Jetpack"><a href="#Jetpack" class="headerlink" title="Jetpack"></a>Jetpack</h4><h5 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h5><p> MVVM ViewModel ViewModelProvider Factory</p><p>多个库组成的套件 基础 架构 行为 界面</p><h5 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h5><p>感知生命周期，响应的时间问题</p><h5 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h5><p>管理页面数据</p><h5 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h5><p>数据持有类 map switchMap</p><h5 id="ViewBinding"><a href="#ViewBinding" class="headerlink" title="ViewBinding"></a>ViewBinding</h5><p>视图绑定</p><h5 id="DataBinding"><a href="#DataBinding" class="headerlink" title="DataBinding"></a>DataBinding</h5><p>数据绑定</p><h5 id="Room框架"><a href="#Room框架" class="headerlink" title="Room框架"></a>Room框架</h5><p>数据库</p><h5 id="Hilt"><a href="#Hilt" class="headerlink" title="Hilt"></a>Hilt</h5><p>依赖注入</p><h5 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h5><p>CoroutineScope async await 协程作用域 </p><p>withContent挂起函数 </p><p>在Retrofit和架构组件里面使用协程 </p><p>Flow 数据流flow以协程为基础构建，可以按顺序发出多个值。冷流 StateFlow SharedFlow</p><p>Paging</p><h5 id="Compose"><a href="#Compose" class="headerlink" title="Compose"></a>Compose</h5><h3 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h3><p>都是问一些底层的运行逻辑，java相关的。</p><p>很多专业术语都是英文首字母简称。</p><p>以下是一些常见的安卓面试问题及其答案总结，涵盖了基础、中级和高级三个层次，帮助你在面试中更好地准备和表现。</p><hr><h3 id="基础问题及答案"><a href="#基础问题及答案" class="headerlink" title="基础问题及答案"></a><strong>基础问题及答案</strong></h3><ol><li><p><strong>Activity的生命周期？</strong></p><ul><li><strong>答案</strong>：<br>Activity生命周期包含<code>onCreate()</code>、<code>onStart()</code>、<code>onResume()</code>、<code>onPause()</code>、<code>onStop()</code>和<code>onDestroy()</code>等方法。<ul><li>**<code>onCreate()</code>**：初始化Activity，加载布局文件。</li><li>**<code>onStart()</code>**：Activity进入前台，但还无法与用户交互。</li><li>**<code>onResume()</code>**：Activity开始与用户交互。</li><li>**<code>onPause()</code>**：Activity失去焦点，但仍可见。</li><li>**<code>onStop()</code>**：Activity不可见。</li><li>**<code>onDestroy()</code>**：Activity被销毁，释放资源。</li></ul></li></ul></li><li><p><strong>Fragment与Activity的区别？</strong></p><ul><li><strong>答案</strong>：<ul><li><strong>Fragment</strong>：Fragment是Activity中的一个可重用UI组件，常用于动态UI和多屏适配。Fragment的生命周期与其宿主Activity密切相关，使用时需要通过FragmentManager进行管理。</li><li><strong>Activity</strong>：Activity是安卓应用的基本组成单元，表示一个单独的UI页面，拥有独立的生命周期。</li></ul></li></ul></li><li><p><strong>Intent与Bundle的区别？</strong></p><ul><li><strong>答案</strong>：<ul><li><strong>Intent</strong>：Intent用于启动Activity、Service、BroadcastReceiver等，它可以携带数据。</li><li><strong>Bundle</strong>：Bundle是一种轻量级的数据存储结构，通常用于在Activity之间传递数据。Intent中可以携带Bundle作为额外数据。</li></ul></li></ul></li><li><p><strong>RecyclerView与ListView的区别？</strong></p><ul><li><strong>答案</strong>：<ul><li><strong>RecyclerView</strong>：RecyclerView是ListView的替代品，支持更加灵活的布局管理器（LayoutManager），并提供了View的回收机制，提高了性能。</li><li><strong>ListView</strong>：ListView只能垂直滚动，性能较低，特别是对于复杂或大量的数据。</li><li><strong>RecyclerView优势</strong>：支持自定义布局管理器（线性、网格、瀑布流），Item动画和高效的ViewHolder复用机制。</li></ul></li></ul></li><li><p><strong>Android中的四大组件是什么？</strong></p><ul><li><strong>答案</strong>：<ul><li><strong>Activity</strong>：用户界面的单个屏幕。</li><li><strong>Service</strong>：用于在后台执行长时间运行的操作。</li><li><strong>BroadcastReceiver</strong>：监听系统广播事件并做出响应。</li><li><strong>ContentProvider</strong>：用于在不同应用之间共享数据。</li></ul></li></ul></li></ol><hr><h3 id="中级问题及答案"><a href="#中级问题及答案" class="headerlink" title="中级问题及答案"></a><strong>中级问题及答案</strong></h3><ol><li><p><strong>Jetpack中的ViewModel是什么？它的作用是什么？</strong></p><ul><li><strong>答案</strong>：<ul><li><strong>ViewModel</strong>：ViewModel是Jetpack组件之一，用于保存UI相关的数据，保证即使在配置变化（如屏幕旋转）时，数据依然不会丢失。它的生命周期独立于Activity和Fragment的生命周期。</li><li><strong>作用</strong>：避免Activity或Fragment被重建时数据丢失，优化UI更新逻辑。</li></ul></li></ul></li><li><p><strong>如何使用Kotlin协程处理异步任务？</strong></p><ul><li><strong>答案</strong>：<br>Kotlin协程提供了一种轻量级的异步编程方式，主要通过<code>launch</code>、<code>async</code>、<code>await</code>等函数实现。<ul><li>使用<code>CoroutineScope.launch</code>在主线程或后台线程执行异步任务。</li><li><code>withContext(Dispatchers.IO)</code>用于切换到IO线程处理耗时任务。</li><li><code>GlobalScope.launch</code>会启动一个全局协程，而<code>lifecycleScope</code>或<code>viewModelScope</code>绑定到特定生命周期，更适合Activity或ViewModel中的异步任务。</li></ul></li></ul></li><li><p><strong>Room数据库的优点是什么？</strong></p><ul><li><strong>答案</strong>：<ul><li><strong>Room</strong>是安卓的对象关系映射（ORM）库，简化了SQLite的使用。</li><li><strong>优势</strong>：<ul><li>提供了类型安全的查询。</li><li>自动处理数据库升级和迁移。</li><li>支持LiveData和Flow，方便进行响应式数据更新。</li><li>减少手动编写SQL代码，防止常见的SQL错误。</li></ul></li></ul></li></ul></li><li><p><strong>如何避免内存泄漏？</strong></p><ul><li><strong>答案</strong>：<ul><li><strong>Context泄漏</strong>：避免在长生命周期的对象（如单例类）中持有Activity的引用，使用<code>ApplicationContext</code>代替<code>ActivityContext</code>。</li><li><strong>Handler泄漏</strong>：及时移除消息队列中的任务，避免任务持有Activity或Fragment的引用。</li><li><strong>AsyncTask泄漏</strong>：AsyncTask应与生命周期绑定，避免任务在Activity销毁后仍在运行。</li><li>使用第三方工具如<code>LeakCanary</code>检测内存泄漏。</li></ul></li></ul></li><li><p><strong>如何处理Fragment与Activity之间的数据通信？</strong></p><ul><li><strong>答案</strong>：<ul><li><strong>使用Bundle传递数据</strong>：通过<code>setArguments(Bundle)</code>在Fragment之间传递数据。</li><li><strong>ViewModel共享数据</strong>：通过<code>ViewModel</code>在Activity和Fragment之间共享数据，特别是使用<code>SharedViewModel</code>来实现多个Fragment之间的数据同步。</li><li><strong>接口回调机制</strong>：在Fragment中定义接口，由Activity实现接口，Fragment通过回调将数据传递给Activity。</li></ul></li></ul></li></ol><hr><h3 id="高级问题及答案"><a href="#高级问题及答案" class="headerlink" title="高级问题及答案"></a><strong>高级问题及答案</strong></h3><ol><li><p><strong>多线程与并发处理，如何保证UI线程不被阻塞？</strong></p><ul><li><strong>答案</strong>：<br>在安卓中，多线程处理通常依赖于<code>Handler</code>、<code>AsyncTask</code>、<code>Thread</code>等机制，现代应用更多使用Kotlin协程。<ul><li><strong>Handler</strong>：用于向主线程发送消息，在指定时机执行任务。</li><li><strong>AsyncTask（已废弃）</strong>：用于在后台线程执行耗时任务，并将结果回传给UI线程。</li><li><strong>协程</strong>：使用<code>launch(Dispatchers.IO)</code>将耗时操作放在后台线程执行，确保UI线程不会阻塞。</li></ul></li></ul></li><li><p><strong>请解释一下MVVM架构模式，以及其优势？</strong></p><ul><li><strong>答案</strong>：<ul><li><strong>MVVM</strong>（Model-View-ViewModel）是安卓常用的架构模式。<ul><li><strong>Model</strong>：数据层，负责数据的获取、处理和存储。</li><li><strong>View</strong>：UI层，展示数据。</li><li><strong>ViewModel</strong>：连接Model与View的桥梁，负责业务逻辑和数据处理。通过<code>LiveData</code>或<code>Flow</code>将数据与UI绑定，实现响应式更新。</li></ul></li><li><strong>优势</strong>：<ul><li>UI和业务逻辑分离，降低耦合性。</li><li>数据和UI的双向绑定（通过<code>DataBinding</code>）简化了UI更新。</li><li>易于进行单元测试。</li></ul></li></ul></li></ul></li><li><p><strong>如何优化安卓应用的启动时间？</strong></p><ul><li><strong>答案</strong>：<ul><li><strong>延迟初始化</strong>：将不必要的初始化操作延迟到Activity启动完成后进行。</li><li><strong>使用Splash Screen</strong>：在启动时使用轻量的启动页，减少主界面的加载时间。</li><li><strong>优化资源加载</strong>：减少布局文件嵌套，使用异步加载图像或其他资源。</li><li><strong>冷启动优化</strong>：减少Application中的全局初始化操作，使用<code>lazy</code>初始化来推迟不必要的初始化。</li></ul></li></ul></li><li><p><strong>安卓中的事件分发机制是如何运作的？</strong></p><ul><li><strong>答案</strong>：<br>安卓事件分发机制依赖于<code>dispatchTouchEvent()</code>、<code>onInterceptTouchEvent()</code>和<code>onTouchEvent()</code>方法。<ul><li>**<code>dispatchTouchEvent()</code>**：将触摸事件分发给当前View及其子View。</li><li>**<code>onInterceptTouchEvent()</code>**：在ViewGroup中决定是否拦截触摸事件。</li><li>**<code>onTouchEvent()</code>**：在子View中处理具体的触摸事件，如点击、滑动等。</li></ul></li></ul></li><li><p><strong>什么是Dagger或Hilt，如何在Android中使用依赖注入？</strong></p><ul><li><strong>答案</strong>：<br><strong>Dagger</strong>和<strong>Hilt</strong>是Android中常用的依赖注入框架，Hilt是Dagger的简化版。<ul><li><strong>依赖注入</strong>：依赖注入是一种设计模式，Dagger和Hilt可以自动管理对象的创建和依赖关系。</li><li><strong>Hilt的使用</strong>：通过<code>@Inject</code>注解构造函数和依赖，使用<code>@Module</code>和<code>@Provides</code>注解提供实例，<code>@Singleton</code>管理单例。</li><li><strong>优势</strong>：减少手动依赖的创建，使代码更清晰、模块化，有助于测试。</li></ul></li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
